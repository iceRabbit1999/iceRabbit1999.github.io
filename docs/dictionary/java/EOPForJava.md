
**写在最前：本篇来源广泛，目前只是自用整理，若有涉及到侵权问题请及时联系邮箱livingsnowman@outlook.com，同时也接受意见或指正。另外，此篇选题有一定的主观性，一些个人认为比较简单的或是自己接触过的再或者比较冷门的知识就没有整理，仅供参阅。**

*此篇长期更新，欢迎 star*

# 牛客选择题

## Java本身及其相关

1. Java有48个关键字，2个保留字，3个特殊直接量(true,false,null),**native，instanceof是关键字**，**true,false,null,　friendly，sizeof不是java的关键字**

2. 可以把任何一种数据类型的变量赋给Object类型的变量 √

3. final的作用：修饰不可变类 ×

4. `SimpleDateFormat`对象是线程不安全的 √；`Arrays.asList`返回的是`java.util.ArrayList`对象 ×

5. 类之间存在的三种关系： USE-A HAS-A IS-A

6. `static class x implements y1,y2 { .... }` ×：

   内部类可以是静态static的，也可用public，default，protected和private修饰，

   外部类的修饰符只能是public，abstract，final



## 数组

1. java中几种数组复制方法的效率：

   System.arraycopy > clone > Arrays.copyOf > for



## IO流

1. OutputStream包含flash()方法，**但InputStream没有**

## 父类与子类问题

1. ```java
   public class Demo {
     class Super {
    
       int flag = 1;
    
       Super() {
         test();
       }
    
       void test() {
         System.out.println("Super.test() flag=" + flag);
       }
     }
     class Sub extends Super {
    
       Sub(int i) {
         flag = i;
         System.out.println("Sub.Sub()flag=" + flag);
       }
       void test() {
         System.out.println("Sub.test()flag=" + flag);
       }
     }
     public static void main(String[] args) {
       new Demo().new Sub(5);
     }
   }
   ```

   正解：

   ```
   Sub.test() flag=1
   Sub.Sub() flag=5
   ```

   注意此处子类重写了父类的test()方法所以应该执行子类的test()

2. **InputStreamReader**可以处理Unicode

3. 父类中的protected方法子类在重写的时候访问权限可以修改

4. 子类的构造器第一行默认都是super()，默认调用直接父类的无参构造，**一旦直接父类没有无参构造，那么子类必须显式的声明要调用父类或者自己的哪一个构造器**

## 泛型

1. 泛型的知识提高了数据传输的安全性，**没有改变程序运行的性能**



## 类型与类型转换

1. ```
   1. byte a1 = 2, a2 = 4, a3;
   2. short s = 16;
   3. a2 = s;
   4. a3 = a1 * a2;
   ```

   第三行和第四行出错：数值型变量在默认情况下为Int型，byte和short型在计算时会自动转换为int型计算，结果也是int 型。所以a1*a2的结果是int 型的。

2. ```java
   public class Test2
   {
       public void add(Byte b)
       {
           b = b++;
       }
       public void test()
       {
           Byte a = 127;
           Byte b = 127;
           add(++a);
           System.out.print(a + " ");
           add(b);
           System.out.print(b + "");
       }
   }
   
   ```

   正解：

   -128 127

   **包装类的值都是final 不可变的**，对于++b 或者b++ ，只是新创建了一个对象，然后把引用传给了原对象句柄，在函数中操作，只是形参的临时句柄改变了指向，实参的句柄还是指向原来的对象。所以即使不是b = b++ 这种，b的值在add之后也是不会变的。(add函数就是摆设)

3. 基本数据类型所占字节：

   | 类型    | 字节 |
      | ------- | ---- |
   | byte    | 1    |
   | short   | 2    |
   | int     | 4    |
   | float   | 4    |
   | double  | 8    |
   | char    | 2    |
   | boolean |      |



## Struts

1. Struts基于MVC框架  √



## Spring

1. Spring提供了AOP方式的日志系统 ×



## 多线程

1. CyclicBarrier和CountDownmLatch可以让一组线程等待其他线程 √
2. ThreadLocal
    1. ThreadLocal继承Object，相当于没继承任何特殊的。
       ThreadLocal没有实现任何接口。
       ThreadLocal并不是一个Thread，而是Thread的局部变量。
    2. ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本
    3. ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏

## 抽象类和接口

简单总结：

**抽象类**

特点:

1.抽象类中可以构造方法

2.抽象类中可以存在普通属性，方法，静态属性和方法。

3.抽象类中可以存在抽象方法。

4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。

5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。

**接口**

1.在接口中只有方法的声明，没有方法体。

2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上

public static final

3.在接口中的方法，永远都被public来修饰。

4.接口中没有构造方法，也不能实例化接口的对象。

5.接口可以实现多继承

6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。



## 异常

1. try- catch-finally
    1. 不管有没有出现异常，finally块中代码都会执行；
    2. 当try和catch中有return时，finally仍然会执行；
    3. **finally是在return后面的表达式运算后执行的**（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；
    4. finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。
2. throws用于抛出异常对象 ×



## JVM

1. off-heap是指JVM进程管理的内存

## 算法

1. 算法结构包括：0个或多个输入、1个或多个输出、中间有穷个处理过程。**存储结构不属于算法结构**



## 网络

| 状态码   | 含义                          |
| -------- | ----------------------------- |
| 200      | OK                            |
| 201      | created 已创建                |
| 204      | No Count 无内容               |
| 302      | 所有请求页面已临时转到新的url |
| 304、307 | 使用缓存资源                  |
| 404      | 无法找到请求页面              |
| 403      | 服务器拒绝访问，权限不足      |
| 409      | 服务器处理请求时发生了冲突    |
| 500      | 请求未完成，服务器出错        |





#牛客299春招课程

## JAVA基础

### 基础

1. 局部变量存储于栈内存；static的成员变量存储于方法区，不是static的成员变量存储于堆内存

2. 实例变量的默认值：

    + byte、short、int：0
    + long：0L
    + float：0.0F
    + double：0.0
    + char：'\u000'
    + boolean：false

3. 如何对Integer和Double类型判断相等

    1. 先转换为相同的基本类型再使用==

4. int和Integer有什么区别，二者在做==运算时会得到什么结果？

    1. 二者在做==运算时，Integer会自动拆箱为int类型，然后再进行比较

5. 对多态的理解

    1. 相同类型的变量、调用同一个方法时呈现出多种不同的行为特征
    2. 多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。

6. 把String设计成final的原因

    1. 安全：String被广泛使用
    2. 多线程中不需要同步的操作
    3. 性能：不变性保证了hashcode的唯一，加强了容器中利用String的效率
    4. 字符串常量池才有意义，节约内存

7. 使用字符串时，new和""推荐使用哪种方式？

    1. 采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。

8. 两个字符串相加的底层是如何实现的

    1. 如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。
    2. 如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。

9. 静态内部类需要满足的规则

    1. 静态内部类可以包含静态和非静态成员
    2. 不能访问外部类的实例成员，只能访问它的静态成员
    3. 外部类的所有方法、初始化块都能访问其内部定义的静态内部类；
    4. 在外部类的外部，也可以实例化静态内部类

10. 说一说你对泛型的理解

    1. 有了泛型以后，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。

11. 泛型擦除

    `List<String> list1 = ...;`

    `List list2 = list1;`


12. 说一说你对Java反射机制的理解

    通过反射机制，我们可以实现如下的操作：

    - 程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；
    - 程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；
    - 程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。

13. Java反射在实际项目中有哪些应用场景？

    1. 使用JDBC时通过反射机制加载数据库的驱动程序；
    2. 注解/XML配置
    3. 面向切面编程（AOP）的实现方案,是程序运行时创建目标对象的代理类

### 容器

1. 描述一下Map put的过程
    1. 首次扩容
        1. 先判断是否为空，为空进行第一次扩容(resize)
    2. 计算索引
        1. 通过hash算法，计算键值对在数组中的索引
    3. 插入数据
        1. 如果当前位置为空，直接插入
        2. 当前位置非空且key存在，直接覆盖value
        3. 当前位置非空且key不存在，将数据链到链表末端
        4. 若链表长度到达8，将链表转换成红黑树，将数据插入书中
    4. 再次扩容
        1. 如果数组中元素个数超过threshold，再次进行扩容
2. 如何得到一个线程安全的Map
    1. 使用Collections工具类，将线程不安全的Map包装成线程安全的Map
    2. 使用ConcurrentHashMap或Hashtable
3. 介绍一下HashMap底层的实现原理
    1. 基于hash算法，通过put方法和get方法存储和获取对象。
    2. 存储对象时用K的hashCode计算hash从而得到bucket位置
    3. 获取对象时调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。
4. 介绍一下HashMap的扩容机制
    1. 数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算
    2. 数组是否需要扩充是通过负载因子判断的
    3. 为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能
5. HashMap中的循环链表是如何产生的？
    1. 两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来
6. 介绍一下ConcurrentHashMap是怎么实现的？
    1. Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap
7. ConcurrentHashMap是怎么分段分组的？
    1. get操作
        1. 先经过一次再散列用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。**整个get过程都不需要加锁，除非读到空的值才会加锁重读。**
    2. put操作
        1. 判断是否要扩容
        2. 定位到添加元素位置，放入数组中
8. 说一说你对LinkedHashMap的理解
    1. 使用双向链表来维护key-value对的顺序
    2. 需要维护元素的插入顺序，因此性能略低于HashMap的性能
    3. 可以避免对HashMap、Hashtable里的key-value对进行排序
9. 请介绍LinkedHashMap的底层原理
    1. 在HashMap的基础上，通过维护一条双向链表，解决了HashMap不能随时保持遍历顺序和插入顺序一致的问题
10. 请介绍TreeMap的底层原理
    1. TreeMap基于红黑树（Red-Black tree）实现
11. 有哪些线程安全的List？
    1. Vector
    2. Colletions.SynchronizedList
    3. CopyOnWriteArrayList
12. 介绍一下ArrayList的数据结构？
    1. ArrayList的底层是用数组来实现的，默认第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量
13. 谈谈CopyOnWriteArrayList的原理
    1. 在写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List。这样就保证了写操作的线程安全
14. 说一说TreeSet和HashSet的区别
    1. HashSet中的元素可以是null，但TreeSet中的元素不能是null；
    2. HashSet不保证元素顺序
    3. HashSet底层是哈希表，TreeSet底层是红黑树
15. 说一说HashSet的底层结构
    1. HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap

### IO

1. 介绍一下Java中的IO流

    1. 按照数据流向，可以将流分为输入流和输出流
    2. 按照数据类型，可以将流分为字节流和字符流，
    3. 按照处理功能，可以将流分为节点流和处理流

2. 怎么用流打开一个大文件？

   避免直接将文件中的数据全部读取到内存中

    1. 缓冲流
    2. 使用NIO

3. 说说NIO的实现原理

    1. Java的NIO主要由三个核心部分组成：Channel、Buffer、Selector。
    2. 基本上，所有的IO在NIO中都从一个Channel开始，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中
    3. Buffer本质上是一块可以写入数据，然后可以从中读取数据的内存。
    4. Selector允许单线程处理多个 Channel，

4. 介绍一下Java的序列化与反序列化

    1. 序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象
    2. 支持序列化需要实现Serializable接口
    3. 实现序列化需要使用对象流ObjectInputStream和ObjectOutputStream

5. Serializable接口为什么需要定义serialVersionUID变量？

    1. 是否允许实现恢复数据的评判标准

6. 除了Java自带的序列化之外，你还了解哪些序列化工具？

    1. JSON
    2. Protobuf

### 多线程

1.  说说Thread类的常用方法
    1. currentThread()：返回当前正在执行的线程；
    2. interrupted()：返回当前执行的线程是否已经被中断；
    3. sleep(long millis)：使当前执行的线程睡眠多少毫秒数；
    4. yield()：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；
2.  run()和start()有什么区别？
    1. run()方法被称为**线程执行体**，它的方法体**代表了线程需要完成的任务**，而start()方法用来启动线程。
3.  线程是否可以重复启动，会有什么后果？
    1. 只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常。
4.  介绍一下线程的生命周期
    1. 新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）和死亡（Dead）
5.  如何实现线程同步？
    1. 同步方法
    2. 同步代码块
    3. ReentrantLock
    4. volatile
    5. 原子变量
6.  说一说Java多线程之间的通信方式
    1. wait()、notify()、notifyAll()
    2. await()、signal()、signalAll()
    3. BlockingQueue
7.  wait和notify
    1. wait()方法可以让当前线程释放对象锁并进入**阻塞**状态。notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入**就绪**队列
8.  如何实现子线程先执行，主线程再执行？
    1. 启动子线程后，立即调用该线程的join()方法，则主线程必须等待子线程执行完成后再执行。
9.  说一说synchronized与Lock的区别
    1. synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。
    2. synchronized可以用在代码块上、方法上；Lock只能写在代码里。
    3. synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。
    4. synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。
    5. synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。
    6. synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率。
10.  synchronized可以修饰静态方法和静态代码块吗？
    1.  synchronized可以修饰静态方法，但不能修饰静态代码块。
11.  如果不使用synchronized和Lock，如何保证线程安全？
    1.  volatile
    2.  原子变量
    3.  本地存储
    4.  不可变的
12.  说一说Java中乐观锁和悲观锁的区别
    1.  悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以**每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。
    2.  每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是**在更新的时候会判断一下在此期间别人有没有去更新这个数据**
13.  了解Java中的锁升级吗？
    1.  无锁
    2.  偏向锁
    3.  轻量级锁
    4.  重量级锁
14.  分段锁是怎么实现的？
    1.  容器里有多把锁，**每一把锁用于锁容器其中一部分数据**，那么当多线程访问容器里不同数据段的数据时，线程间就**不会存在锁竞争**，从而可以有效的提高并发访问效率
15.  volatile关键字有什么用？
    1.  保证可见性
    2.  禁止指令重排
16.  介绍下ThreadLocal和它的应用场景
    1.  每个线程都有自己专属的存储容器，它用来存储线程私有变量。内部真正存取是一个Map
    2.  经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。保证每个线程的都在各自的 Connection 上进行数据库的操作
    3.  ThreadLocal还经常用于**管理Session会话**，将Session保存在ThreadLocal中，使线程处理多次处理会话时始终是同一个Session。
17.  请介绍ThreadLocal的实现原理，它是怎么处理hash冲突的？
    1.  主要利用ThreadLocalMap类，它实现类似map的功能，每一个元素是一个Entry；每个线程有一个自己的map
    2.  get和set操作时都要**获取当前线程**，**取出当前线程的ThreadLocalMap**，然后实施相应的get、set操作
    3.  当出现Hash冲突时采用**线性查找**的方式，如果位置上已经有其他key值的元素利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置
18.  介绍一下线程池
    1.  线程池在系统启动时即创建大量空闲的线程，当run()或call()方法执行结束后，**该线程并不会死亡**，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。
19.  介绍一下线程池的工作流程
    1. 判断**核心线程池**是否已满，没满则创建一个新的工作线程来执行任务。
    2. 判断**任务队列**是否已满，没满则将新提交的任务添加在工作队列。
    3. 判断**整个线程池**是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和（拒绝）策略。
20.  线程池都有哪些状态
    1.  Runnning:能接受新提交的任务,能处理阻塞队列中的任务。
    2.  Shutdown:不再接受新提交的任务但可以继续处理阻塞队列中已保存的任务
    3.  Stop：不能接受新任务，也不处理队列中的任务
    4.  Tidying：所有的任务都已终止
    5.  Terminated：在terminated() 方法执行完后进入该状态
21.  谈谈线程池的拒绝策略
    1.  当线程池的**任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize**，如果还有任务到来就会采取任务拒绝策略：
        1.  AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。
        2.  DiscardPolicy：也是丢弃任务，但是不抛出异常。
        3.  DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复该过程）。
        4.  CallerRunsPolicy：由调用线程处理该任务。
22.  线程池的队列大小你通常怎么设置？
    1.  CPU密集型任务
        1.  尽量使用较小的线程池，一般为CPU核心数+1
    2.  IO密集型任务
        1.  可以使用稍大的线程池，一般为2*CPU核心数
    3.  混合型任务
        1.  分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理
23.  线程池有哪些参数，各个参数的作用是什么？
    1.  corePoolSize 核心工作线程数
    2.  maximumPoolSize 最大线程数
    3.  keepAliveTime 多余线程存活时间
    4.  workQueue 队列
    5.  threadFactory 线程创建工厂
    6.  handler 拒绝策略



### JVM

1. JVM包含哪几部分？

    1. ClassLoader 类加载器
        1. 负责加载字节码文件即 class 文件
    2. Runtime Data Area 运行时数据区，内存分区
        1. 存放数据，分为五部分
            1. Stack 虚拟机栈
            2. Heap 堆
            3. Method Area 方法区
            4. PC Register 程序计数器
            5. Native Method Stack 本地方法栈
    3. Execution Engine 执行引擎
        1. 将 JVM 指令集翻译为操作系统指令集。
    4. Native Interface 本地库接口
        1. 负责调用本地接口

2. JVM是如何运行的？

    1. JVM的装入环境和配置
    2. 装载JVM
    3. 初始化JVM，获得本地调用接口
    4. 运行Java程序

3. Java程序是怎么运行的？

    1.  Java 源代码文件经过 Java 编译器编译成字节码文件后，**通过类加载器加载到内存中**，然后到 Java 虚拟机中解释执行，最后**通过操作系统**操作 CPU 执行获取结果。

4. 说一说Java的内存分布情况

   **线程共享的数据区：方法区、堆**

    1. 程序计数器
        1. 当前线程所执行的字节码的行号指示器
    2. Java虚拟机栈
        1. 描述的是Java方法执行的线程内存模型
        2. 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧
    3. 本地方法栈
        1. 是为虚拟机使用到的本地（Native）方法服务。
    4. Java堆
        1. 几乎所有的对象实例以及数组都应当在堆上分配
    5. 方法区
        1. 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
    6. 运行时常量池
        1. 是方法区的一部分
    7. 直接内存

5. 类存放在哪里？

    1. 方法区

6. 局部变量存放在哪里？

    1. 虚拟机栈

7. 介绍一下Java代码的编译过程

    1. 准备过程
        1. 初始化插入式注解处理器。
    2. 解析与**填充符号表**
        1. 将源代码的字符流转变为标记集合，构造出抽象语法树。
        2. 填充符号表，产生符号地址和符号信息。
    3. 插入式**注解处理**器的注解处理过程
        1. initPorcessAnnotations()
    4. 分析与字**节码生成**过程
        1. 标注检查
        2. 数据流及控制流分析
        3. 解语法糖
        4. 字节码生成

8. 介绍一下类加载的过程

    1. 加载
        1. 通过全限定名来**获取**定义此类的**二进制字节流**。
        2. 将这个字节流所代表的静态存储结构**转化为**方法区的运行时**数据结构**。
        3. 在内存中**生成**一个代表这个类的java.lang**.Class对象**，作为方法区这个类的各种数据的访问入口。
    2. 验证
        1. 文件格式验证
            1. **验证字节流**是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
        2. 元数据验证
            1. 对**字节码描述的信息**进行语义分析验证
        3. 字节码验证
            1. 确定**程序语义**是合法的、符合逻辑的。
        4. 符号引用验证
            1. 对**类自身以外的各类信息**进行匹配性校验
    3. 准备
        1. 正式为类中定义的变量**分配内存**并设置类变量初始值的阶段
    4. 解析
        1. Java虚拟机将常量池内的符号引用替换为直接引用的过程
    5. 初始化
        1. 执行类构造器`<clinit>()`(Javac)编译器的自动生成物方法的过程

9. 介绍一下对象的实例化过程

   具有父类的子类的实例化顺序如下

   | 父类         | 子类         |
      | ------------ | ------------ |
   | 1 静态变量   | 3 静态变量   |
   | 2 静态代码块 | 4 静态代码块 |
   | 5 变量       | 8 变量       |
   | 6 代码块     | 9 代码块     |
   | 7 构造器     | 10 构造器    |

10. 元空间是在栈内还是栈外

    1. 栈外，元空间占用的是本地内存

11. 谈谈JVM的类加载器，以及双亲委派模型

    1. 把类的加载阶段(通过全限定名获取二进制字节流)放到JVM外部实现的动作代码
    2. 双亲委派模型
        1. 工作过程
            1. 如果一个类加载器收到了类加载的请求首先**不会自己去尝试加载这个类**，而是**把这个请求委派给父类加载器**去完成；只有**当父加载器**反馈自己**无法完成**这个加载请求（它的搜索范围中没有找到所需的类）时，**子加载器才会尝试自己去完成加载。**
        2. 好处
            1. Java中的类随着它的类加载器一起具备了一种**带有优先级的层次关系**

12. 双亲委派机制会被破坏吗？

    1. 双亲委派模型主要出现过3次较大规模“被破坏”的情况。

13. 介绍一下Java的垃圾回收机制

    1. 哪些内存需要回收
        1. 处于运行期间程序创建的对象
    2. 怎么定义垃圾
        1. 引用计数算法
            1. 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；**任何时刻计数器为零的对象就是不可能再被使用的。**
        2. 缺点
            1. 有很多例外情况要考虑**要配合大量额外处理**才能保证正确地工作，比如对象之间相互循环引用的问题。
        3. 可达性分析算法
            1. 某个对象到GC Roots(起始节点集)间没有任何引用链相连明此对象是不可能再被使用的。
                1. 固定作为GC Roots的对象：
                    1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象
                    2. 在方法区中类静态属性引用的对象
                    3. 在方法区中常量引用的对象
                    4. Native方法引用的对象
                    5. Java虚拟机内部的引用
                    6. 被同步锁持有的对象。
                    7. 映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
        4. 回收方法区
            1. 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型
    3. 怎么回收垃圾
        1. 分代收集理论
            1. 收集器将Java堆划分出不同的区域，将回收对象依据其年龄分配到不同的区域之中存储
        2. 标记-清除算法
            1. 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，
            2. 缺点：
                1. 执行效率不稳定
                2. 内存空间的碎片化
        3. 标记-复制算法
            1. 将可用内存按容量划分为**大小相等的两块**，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
            2. 缺点：
                1. 浪费内存空间
                2. 对象存活率高时要进行较多复制操作，效率低下
        4. 标记-整理算法
            1. 首先标记出所有需要回收的对象，**让所有存活的对象都向内存空间一端移动**，然后直接清理掉边界以外的内存

14. Full GC会导致什么

    1. Full GC会“Stop The World”**全程暂停用户的应用程序。**

15. JVM中一次完整的GC流程是怎样的？

    1. 新创建的对象一般会被分配在新生代中，Eden 区全部挤满Minor GC 就触发
    2. 根据老年代剩余空间与新生代中对象的大小
        1. 老年代剩余多-->直接Minor GC
        2. 老年代剩余少 --> 检查老年代剩余空间与历次Minor GC生育对象的大小
            1. 老年代剩余大于历次Minor GC剩余对象 -->进行Minor GC
            2. 老年代剩余小于历次Minor GC剩余对象 -->进行Full GC
    3. Minor GC之后有三种情况
        1. Minor GC之后的对象足够放到Survivor区，GC结束
        2. 不够放到Survivor区，接着放入老年代，老年代放得下，GC结束
        3. 老年代放不下 Full GC

16. JVM什么时候触发GC，如何减少FullGC的次数？

    1. 当 Eden 区的空间耗尽时
    2. 减少策略
        1. 增加方法区、老年代空间
        2. 减少新生代
        3. 使用标记-整理算法
        4. 排查无用对象

17. 对象如何晋升到老年代

    1. JVM给每个对象定义了一个年龄计数器，对象每熬过一次Minor GC，年龄+1，年龄达到一定程度(默认15)晋升到老年代

18. 为什么老年代不能使用标记-复制

    1. 老年代的对象都是难以消亡的，复制会操作会很多，效率很低

19. 新生代为什么要分Survivor和Eden，它们的比例是多少

    1. 实际上**98%的对象熬不过第一轮收集**，所以标记-复制算法中**不需要按1:1的比例划分内存**
    2. Apple式回收把新生代分为较大的Eden区和两块较小的Survivor，每次分配只在Eden和一块Survivor，另一块用来复制
    3. 默认比例是8:1

20. 为什么设置两个Survivor

    1. 解决内存碎片化
    2. 保证永远有一个Survivor区是空的，另一个非空Survivor是无碎片的
    3. 再细分容易导致Survivor区被填满

21. 为什么新生代和老年代要采用不同的回收算法

    1. 兼顾垃圾回收的时间开销和内存空间的有效利用

22. 请介绍G1垃圾收集器

    1. 主要面向服务端，自JDK9，开创了收集器**面向局部收集**的设计思路和基于Region的内存布局形式

    2. 把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region可以根据需要扮演Eden、Survivor、老年代

    3. Region的特殊区域Humongous用来存储大对象(超过了一个Region一半)

    4. 好处

        1. 每次收集到的内存空间都是Region的整数倍，避免了全区域的垃圾收集
        2. 根据用户设定的收集停顿时间，优先处理回收价值收益最大的Region(Garbage First的由来)

       ​

23. 请介绍CMS垃圾收集器

    1. 一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法
    2. 运作过程
        1. 初始标记 (需要STOP THE WORLD)
        2. 并发标记 (需要STOP THE WORLD)
        3. 重新标记
        4. 并发清除
    3. 缺点：
        1. 会因为占用了一部分线程导致应用程序变慢，降低总吞吐量
        2. 有可能出现Con-current Mode Failure导致Full Gc
        3. 收集结束时会产生大量碎片空间

24. 内存泄漏和内存溢出有什么区别

    1. 内存泄漏 memory leak
        1. 指程序运行过程中分配的**内存用完后没有被GC回收**，始终在占用内存，**既不能使用又被分配**
    2. 内存溢出 out of memory
        1. 申请的内存大于能够提升的内存导致**无法申请到足够的内存**

25. 什么时候内存泄漏？怎么解决？

    内存泄漏的本质：**长生命周期的对象持有短生命周期对象的引用**

    1. 尽早释放无用对象的引用
    2. 避免在循环中创建对象
    3. 使用字符串时尽量使用StringBuildrer
    4. 少使用静态变量

26. 什么是内存溢出，怎么解决？

    1. 内存溢出的原因
        1. 内存加载数据量过大，如一次从数据库中取出过多数据
        2. 存在死循环或循环产生太多重复对象
        3. 启动参数内存值设定太小
        4. 集合类中对象的引用使用后为清空，是的JVM不能回收
    2. 解决
        1. 修改JVM参数直接增加内存
        2. 检查异常
        3. 使用内存查看工具动态查看内存使用情况
        4. 排查代码中的循环

27. 哪些区域会OOM，怎么触发OOM

    除了程序计数器外的虚拟机内存都有可能发生

    1. Java堆溢出
        1. 对象总容量触及到最大堆容量时
    2. 虚拟机栈和本地方法溢出
        1. 无法申请到足够的内存时
    3. 方法区和运行时常量池溢出
        1. 运行时生成大量动态类的场景
    4. 本地内存直接溢出

## 数据库

### SQL

1. 介绍一下数据库分页

    1. LIMIT子句

        1. 语法

           ```sql
           --返回前5条数据
           select xxx from limit 5
           --从第5行开始返回5条数据
           select xxx from limit 5,5
           ```

        2. 优化

            1. 在页面中限制分页数量
            2. 使用索引覆盖扫描

2. 介绍一下SQL中的聚合函数

    1. COUNT()、AVG()、SUM() MAX() MIN()

3. 表跟表之间是怎么关联的

    1. 内连接
        1. INNER JOIN：返回两张表中满足连接条件的数据
    2. 外连接
        1. 左外连接
            1. LEFT JOIN:返回左表中的所有记录和右表中满足连接条件的记录
        2. 右外连接
            1. RIGHT JOIN:返回右表中的所有记录和左表中满足连接条件的记录

4. SQL中怎么将行转成列

    1. `CASE...WHEN...THEN`
    2. `IF()`

5. 谈谈对SQL注入的理解

    1. 原理
        1. 将SQL代码伪装到输入参数进而传递到服务器执行
    2. 如何解决？
        1. 严格的参数校验
        2. SQL预编译

6. 将一张表的部分数据更新到另一张表，该如何操作？

    1. 关联更新

7. WHERE和HAVING有什么区别？

    1. WHERE
        1. 是一个约束声明，约束来自数据库的内容，**在结果返回前起作用**，WHERE中不能使用聚合函数
    2. HAVING
        1. 是一个过滤声明，**在返回结果后进行过滤**，HAVING可以使用聚合函数

   分组应该用HAVING

### 索引

1. 谈谈你对MySQL索引的理解

    1. 是一个单独的、存储在磁盘上的数据结构，包含对数据表里所有记录的引用指针。
    2. 不同的存储引擎支持的索引不同
    3. 优点
        1. 唯一索引可以保证每一行数据的唯一性
        2. 加快查询速度
        3. 加速表之间的连接
    4. 缺点：
        1. 创建和维护索引要耗费时间
        2. 索引需要占用磁盘空间
        3. 对表数据进行增删改查的时候索引也要动态维护，降低速率

2. 索引有哪几种

    1. 普通索引和唯一索引
        1. 普通索引：基本索引类型，允许插入重复值和空值
        2. 唯一索引：索引列的值必须唯一，允许有空值；
            1. 主键索引是特殊的唯一索引，不允许有空值
    2. 单列索引和组合索引
        1. 单列索引：一个索引只包含一个列
        2. 组合索引：在表的多个字段组合上创建的索引，**遵循最左前缀集合。**
    3. 全文索引
        1. MySQL中只有MyIsam支持，类型为FULTEXT
    4. 空间索引
        1. 对空间数据类型的字段建立的索引，MySQL中只有MyIsam支持

3. 如何创建和保存MySQL索引

    1. 在创建表的时候创建索引

        1. 语法

           ```sql
           create table xxx [col_name data type]
           [unique|fulltext|spatial][index|key][index_name](col_name [length]) [ASC|DESC]
           --unique fulltext spatial为可选参数，分别表示唯一索引、全文索引和空间索引
           --示例
           CREATE TABLE t1(
               id INT NOT NULL,
               name CHAR(30) NOT NULL,
               UNIQUE INDEX UniqIdx(id)
           )
           ```

    2. 在已存在的表上创建索引

        1. 语法

           ```sql
           --可以使用ALTER或者CREATE
           ALTER TABLE book ADD UNIQUE INDEX UNIQidIdx(bookId)
           
           CREATE UNIQUE INDEX UniqidIdx ON book (bookId)
           ```

4. MySQL怎么判断要不要加索引

    1. 当唯一性是某数据的特征时，指定唯一索引
    2. 频繁进行排序或分组的列上建立素索引

5. 如何判断索引是否生效

    1. 用EXPLAIN语句

       ```sql
       EXPLAIN SELECT * FROM WHERE index_name=xxx;
       ```

6. 何如评估一个索引是否合理

    1. 避免对经常更新的表创建过多索引
    2. 数据量小的表最好不要用索引
    3. 在不同的值较多的列上建立索引
    4. 唯一索引建立在唯一性的数据上
    5. 在频繁分组或排序的列上建立建立索引

7. 索引失效怎么解决

    1. 遵循最左前缀原则
    2. 不在索引上做任何操作
    3. 尽量使用覆盖索引
    4. 少用or
    5. 字符串不加单引号会导致索引失效
    6. 检查!=<>符号处
    7. 检查LIKE以通配符开头处(LIKEname)

8. 哪些字段不适合创建索引

    1. 频繁更新的
    2. where中用不到的
    3. 数据少的表
    4. 数据重复且分布均匀
    5. 参与列计算的

9. 索引的实现原理

   MySQL中索引是在存储引擎层实现的

    1. MyISAM索引实现
        1. B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
        2. 辅助索引是一颗B+Tree，data域保存数据记录的地址
    2. InnoDB
        1. 也是用B+Tree但实现原理不同。InnoDB的数据文件本身就是索引文件
        2. InnoDB的辅助索引data域存储相应记录主键的值而不是地址

10. 介绍一下数据库索引的重构过程

    1. 什么时候需要重建索引

        1. 表频繁发生改、删操作
        2. rowid产生变化

    2. 怎么判断该不该重建索引

        1. 看索引是否严重倾斜，浪费了空间
        2. 索引深度>=4时

    3. 如何重构索引

        1. drop之后再创建

           ```sql
           drop index index_name
           ```

        2. 直接重建索引

           ```sql
           alter index index_name rebuild
           ```

    4. rebuild重建索引的过程

        1. 读取原索引中的数据构建新的索引
        2. 产生一个临时日志表记录所有rebuild online时索引的变化
        3. 新的索引构建完以后，把日志表的内容维护到新的索引
        4. drop掉旧的索引
        5. 注意事项
            1. 需要检查表空间是否足够
            2. 最好在业务不繁忙的时间段

11. MySQL索引为什么用B+树

    1. 所有记录节点都是按照键值的大小魂虚存放在同一层的叶子节点
    2. 高扇出性，速率优势

12. 联合索引的存储结构是什么，它的有效方式什么

    1. 本质上还是B+Tree，但是键值数量>=2
    2. 遵循最左前缀集合

13. **MySQL的Hash索引和B树索引有什么区别？**(面试真题)

    1. hash索引等值查询更快，但无法范围查询
    2. hash索引不支持使用索引进行排序
    3. hash索引不支持模糊查询以及多列查询的最左匹配
    4. hash索引避免不了回表查询数据
    5. hash索引不稳定，不可预测

14. 聚簇索引和非聚簇索引有什么区别？

    无论何种索引，大小都为16KB且不能更改

    1. 聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录
    2. 非聚簇索引索引是根据聚簇索引键创建的一棵B+树，叶子节点仅存放索引键值，以及该索引键值指向的主键

15. 什么是联合索引

    1. 联合索引对表上的多个列进行索引，本质还是B+Tree,遵循最左前缀

16. select in中如何使用索引

    1. 如果字段类型为字符串	，要给in查询中的数值和字符串加引号
    2. 字段为int不需要加引号

17. 模糊查询中如何使用索引？

    1. `like '%8787aa'`不能用索引

### 事务

1. 说一说你对数据库事务的了解

    1. ACID特征

        1. Atomicity 原子性
            1. 不可分割
        2. Consistency 一致性
            1. 事务从一种状态转变为另一种一致的状态
        3. Isolation 隔离性
            1. 每个读写的对象与其他事务操作对象相互分离
        4. Durability 持久性
            1. 事务一旦提交，结果是永久性的

    2. 事务类型

        1. 扁平事务

            1. 所有操作处于同一层次，要么都执行要么都回滚
            2. 带有保存点的扁平事务
                1. 允许事务在执行中回滚到同一事物较早的某个状态

        2. 链事务

            1. 提交事务时，将必要的处理上下文传给下一个要开始的事务

        3. 嵌套事务

            1. 是一个层次结构框架。顶层事务控制子事务

        4. 分布式事务

            1. 在分布式环境下运行的扁平事务

           MySQL不支持嵌套事务

2. ACID特性是怎么实现的

3. 谈谈MySQL的事务隔离级别

    1. 读未提交
        1. 性能最好，不加锁，可以理解为没有隔离
    2. 读提交
        1. 读的时候加共享锁，写的时候加排它锁
    3. 可重复读
        1. MVVC方式(多版本控制并发)
    4. 串行化

   |     隔离级别     |  脏读  | 不可重复读 |  幻读  |
      | :--------------: | :----: | :--------: | :----: |
   | READ UNCOMMITTED |  可能  |    可能    |  可能  |
   |  READ COMMITTED  | 不可能 |    可能    |  可能  |
   | REPEATABLE READ  | 不可能 |   不可能   |  可能  |
   |   SERIALIZABLE   | 不可能 |   不可能   | 不可能 |

4. MySQL事务如何回滚

   默认配置自动提交回滚

    1. ROLLBACK
    2. ROLLBACK TO [SAVEPOINT] identifier



### 锁

1. 了解数据库的锁吗？

   锁机制用于管理对共享资源的并发访问

    1. 锁的类型

        1. 共享锁 S Lock
            1. 允许事务读一行数据
        2. 排它锁 X Lock
            1. 允许事务删除或更新一条数据
            2. 与任何锁不兼容

    2. 锁的粒度

       InnoDB支持多粒度锁定，允许事务在行级上的锁和表级上的锁同时存在

        1. 意向锁
            1. 将锁定的对象分为多个层次，即在更细的粒度上加锁
            2. 意向共享锁 IS
            3. 意向排它锁 IX

    3. 锁的算法

        1. Record Lock
            1. 单个行记录上的锁
        2. Gap Lock
            1. 间隙锁，锁定一个范围但不包含本身
        3. Next-Key Lock
            1. 锁定一个范围且记录本身

    4. 死锁

        1. 两个或以上的事务执行过程中因争夺资源互相等待
        2. 解决死锁
            1. 超时
            2. 等待图 wait-for graph
                1. 锁的信息链表
                2. 事务等待链表

    5. 锁的升级

        1. 指将当前锁的粒度降低

2. 介绍一下间隙锁

    1. 为了阻止多个事务将记录插入到同一范围，导致幻读

3. InnoDB中行级锁怎么实现

    1. 通过给索引上的索引项加锁
    2. 只有通过索引条件检索数据才是用行级锁

### 优化

1. 说一说对数据库优化的理解

    1. 原则
        1. 减少系统瓶颈、减少资源占用、增加系统反应速度
    2. 针对查询
        1. 使用索引、使用连接替代子查询
    3. 针对慢查询
        1. 分析日志
    4. 针对插入
        1. 禁用索引禁用、禁用检查、禁用外键检查、禁用自动提交、禁用唯一性检查
    5. 针对数据库结构
        1. 拆表、增加中间表、增加冗余字段

2. 该如何优化MySQL的查询

    1. 使用索引
        1. 索引不起作用的三种情况
            1. like %xx
            2. 不满足最左前缀
            3. 使用or的查询
    2. 优化子查询
        1. join替代子查询

3. 表中有几千万条数据怎么办？

    1. 优化SQL和索引
    2. 增加缓存
    3. 读写分离
    4. 使用分区表
    5. 垂直于水平拆分

4. 对MySQL的慢查询优化有了解吗？

    1. 索引没有起作用
        1. 检查like、or、最左前缀
    2. 优化数据结构
        1. 分表
        2. 建立中间表
    3. 分解关联查询
    4. 优化LIMIT分页

5. 说说对explain的了解

    1. 基本语法

        1. `EXPLAIN [EXTENED] SELECT XXX`

    2. 查询结果

       |  列名   |                             备注                             |
             | :-----: | :----------------------------------------------------------: |
       |  type   |    本次查询表联接类型，从这里可以看到本次查询大概的效率。    |
       |   key   |   最终选择的索引，如果没有索引的话，本次查询效率通常很差。   |
       | key_len |             本次查询用于结果过滤的索引实际长度。             |
       |  rows   |     预计需要扫描的记录数，预计需要扫描的记录数越小越好。     |
       |  Extra  | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

### 其他

1. 介绍一下三大范式
    1. 第一范式
        1. 数据库的每一列都应该是**不可再分割**的
    2. 第二范式
        1. 非码属性必须完全依赖于候选码
        2. 即在第一范式的基础上消除部分函数依赖
    3. 第三范式
        1. 任何非主属性不依赖于其它非主属性
        2. 即在第二范式基础上消除传递依赖
2. 说一说对MySQL引擎的了解
    1. InnoDB
        1. 支持事务、行锁定和外键
    2. MyISAM
        1. 较高的插入、查询速度，不支持事务
3. 说一说对redo log、undo log、binlog的了解
    1. binlog
        1. 二进制日志文件，记录所有修改数据库的操作
    2. redo log
        1. 重做日志用来实现事务持久性
    3. undo log
        1. 记录回滚信息
4. 谈谈对MVCC的了解
    1. InnoDB的默认隔离级别可重复读是用的是MVCC
5. MySQL主从同步是如何实现的
    1. 主服务器把数据更改记录到二进制日志
    2. 从服务器把二进制日志复制到自己的中继日志
    3. 从服务器重做中继日志，把更改同步到自己的数据库

## Web开发

### SpringBoot

1. 说说你对SpringBoot的理解

    1. 本质上就是Spring。做了没有它也可以完成的配置
    2. 优点
        1. 快速构建项目
        2. 对主流框架无配置集成
        3. 项目可独立运行
        4. 提供应用监控
        5. 提高开发和部署效率
        6. 与云计算天然集成

2. Spring Boot Starter有什么用

    1. 众多起步依赖之一，本质上是Maven项目对象的模型

3. 介绍SpringBoot的启动流程

    1. SpringApplication调用run方法
        1. 获取并启动监听器和参数配置
        2. 初始化
        3. 容器的初始化(创建、准备、初始化)
        4. 监听器发送通知

4. 描述SpringBoot自动装配的过程

    1. @EnableAutoConfiguration开启自动配置，扫描注册内容，实例化满足条件的Bean，注入容器

5. SpringBoot注解的了解

    1. @SpringBootApplication

        1. 入口类注解，用于开启自动配置

        2. 由三个注解组成

            1. @EnableAutoConfiguration
            2. @SpringBootConfiguration
            3. @CompontScan

        3. @Import

            1. 是@EnableAutoConfiguration的组成部分

        4. @Conditional

            1. 指定Bean是否满足自动装配条件

           ...

### Spring

1. 请说说Spring的核心是什么/有哪些模块(面试真题)

    1. Spring包含众多模块，Core、Testing、Data Access、Web Servlet...
    2. 最核心的是Core
        1. 提供了IOC容器、AOP功能、数据绑定、类型转换等
    3. IOC
        1. 控制反转，把new对象的权利交给程序并让其帮助维护对象之间的关系
    4. AOP
        1. OOP的补充，统一解决一批组件的共性需求：权限检查、日志、事务等

2. 说一说对Spring容器的了解

    1. BeanFactory
        1. 基础容器。启动初期速度快，所需资源有限，适合对功能要求不严格的场景
    2. ApplicationContext
        1. 高级容器，提供事件发布、国际化信息。要求更多资源

3. 说一说对BeanFactory的了解

    1. 是类的通用工厂，创建并管理各种类的对象
    2. Spring容器的顶层接口

4. 说一说对IOC的理解

    1. 定义见问题1
    2. 实现
        1. DI(Dependency Injection)依赖注入是IOC的实现方式
        2. 三种注入方式
            1. 构造方法注入
                1. 在被注入对象构造方法中声明依赖对象的参数列表
            2. setter方法注入
                1. 通过setter方法更改响应的对象属性
            3. 接口注入
                1. 通过IOC Servie Provider注入，要求必须实现某个接口。IOC Servie Provider通过该接口了解应该注入什么对象
    3. Spring是如何管理Bean的
        1. IOC容器，可以通过XML或注解管理
        2. 管理Bean时常用的注解
            1. @ComponentScan
            2. @Conponent
            3. @Autawired、@Qualifier
            4. @Scope
            5. @PostConstruct、@PreDestroy

5. 1. 介绍Bean的作用域

    1. 默认是singleton单例

       |     类型      |                             说明                             |
                | :-----------: | :----------------------------------------------------------: |
       |   singleton   |    在Spring容器中仅存在一个实例，即Bean以单例的形式存在。    |
       |   prototype   |   每次调用getBean()时，都会执行new操作，返回一个新的实例。   |
       |    request    |              每次HTTP请求都会创建一个新的Bean。              |
       |    session    | 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。 |
       | globalSession |    同一个全局的Session共享一个Bean，一般用于Portlet环境。    |

6. 说一说Bean的生命周期

    1. Spring启动，进行Bean的实例化
    2. Bean属性注入
    3. 根据是否实现对应接口调用相关方法
    4. Bean准备就绪
    5. 销毁

7. Spting是怎么解决循环依赖的？

    1. 三种情况
        1. 构造器的循环依赖
            1. Spring处理不了，抛出异常
        2. 单例模式的setter循环依赖
            1. 通过三级缓存处理
        3. 非单例循环依赖
            1. 无法处理

8. @Autowired和@Resource有什么区别

    1. @Autowired是Spring提供的注解，@Resource是JDK提供的
    2. @Autowired按类型注入，@Resource默认按名称，但也支持类型
    3. @Autowired默认情况要求依赖对象必须存在，可与@Qualifier一起使用；@Resource两个属性name和type，一旦指定name，只能按名称装配

9. Spring默认提供的单例模式是安全的吗？

    1. 不是

10. 对AOP的理解

    1. OOP将程序抽象成不同的层次，AOP将程序抽象成各个切面
    2. AOP术语
        1. 连接点
            1. 对应具体被拦截的对象
        2. 切点
            1. 适配连接点
        3. 通知
            1. 约定流程下的方法，会织入流程
        4. 目标对象
            1. 被代理对象
        5. 引入
            1. 引入新的类和方法
        6. 织入
            1. 将切点与匹配的连接点拦截，按约定把通知纳入流程
        7. 切面
            1. 可以定义切点和各类通知和引入
    3. 实现方式
        1. JDK动态代理
            1. Java提供，在运行时创建接口的代理实例
        2. CGLib动态代理
            1. 底层字节码技术，在运行时创建子类代理的实例，目标对象不存在接口时采用

11. AOP的应用场景

    1. 日志、事务处理、权限管理

12. Spring AOP不能对哪些类进行增强

    1. AOP只能对IOC容器中的Bean进行增强
    2. CGLib不能对final的类代理

13. 既然有没有接口都可以用CGLib，那为什么还要有JDK代理

    1. CGLib创建代理花费的时间较多，JDK适用于需要频繁创建代理对象的场景

14. Spring如何管理事务

    1. 编程式事务
        1. 麻烦但灵活且事务控制精确
    2. 声明式事务
        1. @Transaction

15. Spring的事务传播方式有哪些？

    1. |       事务传播类型        |                             说明                             |
              | :-----------------------: | :----------------------------------------------------------: |
       |   PROPAGATION_REQUIRED    | 如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。 |
       |   PROPAGATION_SUPPORTS    |     支持当前事务，如果当前没有事务，则以非事务方式执行。     |
       |   PROPAGATION_MANDATORY   |        使用当前的事务，如果当前没有事务，则抛出异常。        |
       | PROPAGATION_REQUIRES_NEW  |        新建事务，如果当前存在事务，则把当前事务挂起。        |
       | PROPAGATION_NOT_SUPPORTED |  以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。  |
       |     PROPAGATION_NEVER     |     以非事务方式执行操作，如果当前存在事务，则抛出异常。     |
       |    PROPAGATION_NESTED     | 如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

16. @Transactional

    1. 标注在类上
        1. 这个类的所以public非静态方法都将开启事务
    2. 标注在方法
        1. 该方法开启事务

### SpringMVC

1. 什么是MVC？
    1. 一种设计模式。Model、View、Controller
2. DAO层是做什么的？
    1. 数据访问对象，专门用来访问数据库
3. 介绍一下MVC执行流程
    1. 客户端发送HTTP请求，服务端接受请求
    2. DispatcherServlect根据请求信息以及HandlerMapping找到对应的Handler
    3. 通过HandlerAdapter对Handler进行封装和处理
    4. 返回ModeAndView对象给DispatcherServlet，再由ViewResolver完成视图处理返回View
    5. 渲染以后返回客户端
4. 说一说你知道的SpringMVC注解
    1. @RequestMapping
        1. 指定请求路径
    2. @RequestParam
        1. 将请求参数绑定到控制器方法
    3. @RequestBody
        1. 返回结果直接写入Http的Responsebody
    4. PathVaribale
        1. 绑定url中的占位符
5. 介绍一下SpringMVC的拦截器
    1. 执行流程
        1. preHandle方法，返回布尔值作为是否下一步的依据
        2. 执行处理逻辑
        3. postHandle方法
        4. 视图解析和渲染
        5. arfterCompletion方法
    2. 开发流程
        1. 开发拦截器
            1. 实现`handlerIntercepter`接口，选择合适的方法实现具体业务逻辑
        2. 注册拦截器
            1. 定义配置类，实现WebMvcConfiguration，在接口的
6. 怎么做请求拦截
    1. 对controller记性拦截
        1. SpringMVC拦截器
    2. 对所有请求
        1. Filter
    3. 对除了Controller之外的其他Bean
        1. 使用AOP

### MyBatis

1. 谈谈MyBits和JPA的区别
    1. ORM映射不同
        1. MyBatis是半自动，JPA是全自动
    2. 可移植性不同
        1. MyBatis移植成本很高，因为要写SQL
    3. 日志系统完整性不同
        1. JPA日志系统健全涉及广泛；MyBatis日志功能薄弱
    4. SQL优化区别
        1. MyBatis优化方便很多
2. MyBatis输入输出支持的类型
    1. 简单类型
        1. 整数、小数、字符串
    2. 集合类型
    3. 自定义JavaBean
3. MyBatis如何实现一对多关联查询？
    1. 嵌套查询
        1. 通过select定义查询主表的SQL，返回结果通过resultMap映射
    2. 嵌套结果
        1. 通过select标签定义关联查询主表和子表SQL
4. MyBatis中$和#有什么区别？(面试真题)
    1. \#设置参数时会进行预编译
    2. $设置参数只是创建普通的SQL语句，将参数直接拼到SQL语句
        1. 不安全但可以解决特殊情况
            1. 比如动态表格传递SQL列名
5. MyBatis的xml文件和Mapper是怎么绑定的(面试真题)
    1. 通过xml文件中`<mapper>`标签的namespace，即接口的全限定名
6. MyBatis分页和自己写的分页哪个效率高？
    1. 自己写的效率高
        1. MyBatis分页是拦截查询SQL，在其基础上加limit
7. 了解MyBatis缓存机制吗？
    1. 一级缓存
        1. 也叫本地缓存，默认启用且不能关闭
        2. 同一个SqlSession查询时会通过算法生成缓存的键值，键入Map对象
        3. 再产生同样的查询结果时会返回缓存的对象
    2. 二级缓存
        1. 是SqlSessionFactory级别的缓存
        2. 特点
            1. 映射语句文件中的所有SELECT 语句将会被缓存。
            2. 映射语句文件中的所有时INSERT 、UPDATE 、DELETE 语句会刷新缓存。
            3. 缓存会使用Least Rece ntly U sed ( LRU ，最近最少使用的）算法来收回。
            4. 根据时间表（如no Flush Int erv al ，没有刷新间隔），缓存不会以任何时间顺序来刷新。
            5. 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用。
            6. 缓存会被视为read/write（可读／可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改

### 其他

1. cookie和session的区别是什么
    1. 存储位置
        1. cookie存放客户端，session存放服务端
    2. 存储容量
        1. 单个cookie<=4KB,一个站点最多保存20个cookie，session没有上限
    3. 存储方式
        1. cookie只能保存ASCII字符串，session可以保存任意类型
    4. 隐私策略
        1. cookie对客户端可见，不安全；session对客户端不可见
    5. 生命周期
        1. cookie可以通过设置长期有效，session不能长期有效
    6. 服务器压力
        1. cookie不占用服务器，每个用户都会产生一个session在服务端
    7. 跨域支持
        1. cookie支持跨域，session不支持跨域
2. cookie和session各自适合什么场景？
    1. session
        1. 敏感数据
    2. cookie
        1. 普通数据
3. 介绍session的工作原理
    1. 客户端首次访问服务器，服务器产生session对象且该对象有唯一标识SESSIONID
    2. 同时在响应阶段服务端创建一个cookie，将SESSIONID存入
    3. 客户端通过响应的cookie来持有SESSIONID，再次访问服务端时，服务端会获取到cookie中的SESSIONID，找到对应的session对象，进而获取响应状态
4. get和post的区别(面试真题)
    1. 浏览器退回时
        1. GET无害，POST会再次提交请求
    2. GET产生的url地址可以被Bookmark，POST不行
    3. GET会被浏览器主动cache，POST需要手动设置
    4. GET只能url编码，POST支持多种
    5. GET参数被保留在浏览器历史记录，POST不会
    6. GET在URL传送的参数有长度限制，POST没有
    7. GET通过URL传递，POST通过RequestBody
5. get请求的参数能放到body里吗？
    1. 可以但不建议
6. post不幂等是为什么？
    1. POST所对应的URI并非创建的资源本身。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。所以，POST方法不具备幂等性。
7. 400是什么意思
    1. 请求的语义有误，当前请求无法被服务器理解
8. 请求数据出现乱码怎么处理？
    1. 原因是客户端与服务端编码方案不一致
        1. 用中间相互转化
        2. 显示声明实体内容或请求路径编码与服务器一致
9. 如何在SpringBoot框架下实现一个定时任务
    1. Spring提供了可执行定时任务的线程池，在配置类中启用线程池注解即可
10. 调用接口时要记录日志，该怎么设计
    1. 可以定义一个组件，通过AOP织入到接口的调用



## 中间件

## 分布式

## 操作系统

### Linux

1. Linux如何查看一个想知道的进程

    1. ps
        1. ps -aux | grep PID:查找某进程
        2. ps -A 显示所有进程

2. Linux如何查看带有关键字的日志文件？

    1. cat 路径/文件名 | grep 关键词
        1. `cat test.log | grep "http"` 返回test.log中包含http的所有行
    2. grep -i 关键词 路径/文件名

3. 说说对grep命令的了解？

    1. 文本搜索命令，全局正则表达搜索
    2. 在一个或多个文件中搜索字符串模板，搜索的结果不影响原文件内容

4. Linux修改主机命令是什么？

    1. 临时更改主机名
        1. hostname
        2. `sudo hostname newname`
    2. 永久改变主机名
        1. hostnamectl
        2. `sudo hostnamectl set-hostname newname`

5. Linux开机自动执行命令如何实现

    1. 使用cron任务
        1. cron守护进程必须处于运行
        2. 脚本或crontab文件必须包含环境变量
    2. 使用/etc/rc.d/rc.local

6. Linux查看内存的命令是什么？

    1. free命令 free -m
        1. 包括实体内存、虚拟交换文件内存、共享内存、系统核心使用缓存
    2. top命令
        1. 显示当前系统正在执行的进程的相关信息，包括进程ID，内存占用率、CPU占用率等

7. Linux中压缩文件的命令是什么

    1. tar
        1. 备份文件
    2. gzip
        1. 压缩文件
    3. bz2
        1. 创建压缩包
    4. compress
        1. 远古unix档案压缩命令
    5. zip
        1. 压缩文件
    6. unzip
        1. 解压zip文件

8. Linux查询连接数的命令

    1. netstat

9. Linux如何通过端口查进程，如何通过进程查端口

    1. 通过进程查端口
        1. 先查看pid
            1. ps -ef | grep 进程名
        2. 通过pid查看端口
            1. netstat - nap | grep pid
    2. 通过端口查进程
        1. netstat -nap | grep 端口号

10. Linux说一说ping命令

    1. 检测主机
        1. 使用ICMP传输协议，发出要求回应的信息，若主机网络功能正常会回应该信息

11. 说一说你对Linux内核的了解

    内核是操作系统的核心，是驻留在内存中的软件，4项工作：

    1. 内存管理
        1. 追踪记录有多少内存、存储了什么、存储在哪里
    2. 进程管理
        1. 确定哪些进程可以使用CPU、如何使用、使用多久
    3. 设备驱动程序
        1. 硬件与进程之解释程序
    4. 系统调用和安全防护
        1. 从流程接受服务请求

12. 说一说对Linux内核态与用户态的了解(面试真题)

    1. 内核态
        1. 本质上就是内核，一种特殊的软件程序，控制计算机硬件资源并提供稳定的环境供程序运行
    2. 用户态
        1. 就是提供应用程序运行的空间，内核提供接口事程序访问到其管理的资源，这些接口就叫系统调用
    3. 用户态到内核态的切换
        1. 系统调用
            1. 软件中断
        2. 异常
            1. 用户态发生了异常就会触发切换
        3. 外设中断
            1. 外设完成用户的请求向CPU发送中断信号

13. Linux负载是什么

    1. (load)是Linux的重要指标，直观反应了机器当前的状态
    2. UNIX中被定义为特定时间间隔内运行队列中的平均线程数

14. Linux如何设置开机启动

    1. 编辑rc.local脚本
    2. 添加开机启动服务

15. 谈谈Linux的内存管理

    1. 虚拟内存
    2. 大页机制
    3. 区域概念
    4. 节点
    5. page cache
    6. 匿名内存
    7. 内存回收
    8. 段页机制

16. 深拷贝和浅拷贝的区别

    1. 浅拷贝
        1. 只是对指针的拷贝，拷贝后两个指针指向同一个内存空间；
    2. 深拷贝
        1. 不单对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同的地址空间。

17. Linux中的软链接和硬链接有什么区别

    1. 软链接

        1. 相当于建立了一个新的快捷方式，访问该快捷方式会定向到原始文件

    2. 硬链接

        1. 为当前文件建立一个文件别名，建立之后无法区分谁是原文件名称

    3. 区别

        1. 软链接可以为文件和目录（哪怕是不存在的）创建链接；硬链接只能为文件创建链接。
        2. 软链接可以跨文件系统；硬链接必须是同一个文件系统
        3. 硬链接因为只是文件的一个别名，所以不重复占用内存；软链接因为只是一个访问文件的快捷方式文件，文件内只包含快捷指向信息，所以占用很小的内存
        4. 软链接的文件权限和源文件可以不一样；硬链接文件权限肯定是一样的，因为他们本来就是一个文件的不同名称而已。

       重要的文件用硬链接作备份

18. Linux替换文本如何操作？

    1. 通过vi编辑器
        1. :s
    2. 直接替换文件中的字符串
        1. prel命令
        2. sed命令

###进程

1. 什么是协程

    1. 是微线程，在子程序内部执行，中断转而执行别的子程序再返回来接着执行
    2. 线程和协程的区别
        1. 协程执行效率极高。(因为基本没有内核切换的开销)
        2. 协程不需要多线程的锁机制，从属于一个线程，不存在冲突
        3. 一个线程可以有多个协程
    3. 协程的优势
        1. 协程调用跟切换比线程效率高
        2. 占用内存少
        3. 开销少

2. 线程和进程的区别(面试真题)

    1. 一个进程可以包含多个线程，一个线程从属于一个进程
    2. 进程挂掉不会影响其他进程
    3. 进程是系统资源调度的最小单位；线程是CPU调度的最小单位
    4. 进程开销大
    5. 进程拥有独立内存单元
    6. 通信方式不一样

3. 进程切换为什么比线程消耗更多资源

    1. 进程切换需要刷新TLB并获取新的地址空间
    2. 保存线程的上下文比进程的上下文小

4. 介绍一下进程之间的通信

    1. 匿名管道
        1. 半双工，数据单向流动且只有亲缘关系(父子)的进程使用
    2. 有名管道
        1. 先进先出，不需要有亲缘关系
    3. 信号
        1. 可以在任意时刻发送给某一进程
    4. 消息队列
        1. 存放在内核中的消息链表
    5. 共享内存
    6. 信号量
        1. 解决进程和线程间并发执行的同步问题
        2. P操作(信号量值-1)和V(信号量值+1)操作
    7. socket

5. 说说僵尸进程和孤儿进程

    1. 孤儿进程
        1. 一个父进程退出，它的一个或多个子进程还在运行
        2. 孤儿线程将被init进程收养，并完成状态收集
    2. 僵尸进程
        1. 一个进程使用fork创建子进程，子进程退出，父进程没有调用wait或waitpid，子进程的描述符仍保存在系统

6. 介绍线程之间的通信方式

    1. 锁机制
    2. 信号量机制
        1. 无名线程信号量
        2. 命名线程信号量

7. 进程的状态

8. 进程之间共享内存的通信方式有什么好处

    1. 效率高
        1. 进程可以直接读写内存，不需要拷贝数据

9. 如何杀死一个进程

    1. 杀死父进程并不会同时杀死子进程
    2. kill
    3. killall

10. 说一说kill的命令

    1. 向操作系统内核发送一个信号，系统内核根据信号进行相应的操作
    2. kill知识发送一个信号，只有当信号被捕获的时候才会执行

11. 介绍下你知道的锁

    1. 悲观锁
    2. 乐观锁
    3. 自旋锁
        1. 基础的同步原语，保障对共享数据的互斥访问
        2. 线程等待自旋锁的时候，CPU不能做任何事
    4. 公平锁
        1. 多个线程竞争一把锁，先到先得
    5. 非公平锁
    6. 共享锁
        1. 多个线程共享锁的拥有权
    7. 死锁

12. 什么情况会产生死锁

    1. 互斥条件
        1. 即某个资源不能同时被两个或以上进程占有
    2. 不剥夺条件
        1. 进程获得的资源在未使用完毕前，不能强行夺取
    3. 请求和保持条件
        1. 进程至少已经占有一个资源，但又申请新的资源
    4. 循环等待条件
        1. 在等待序列中出现互相等待

    只要一个必要条件不满足，死锁就可以排出

13. 说说对自旋锁的理解

    1. 定义
        1. 线程尝试获取锁的时候锁已被占用，线程会一直等待，间隔一段时间后会再次尝试获取
    2. 特点
        1. 用于临界区互斥
        2. 在任何时刻最多只能有一个执行单元获得锁
        3. 等待锁的线程进入忙循环
    3. 存在的问题
        1. 如果某线程持有锁的事件过长，会让等待的线程进入一直循环，消耗CPU
        2. 无法满足等待时间最长的线程优先获取锁
    4. 优点
        1. 不会使线程状态发生切换，减少不必要的上下文切换，执行速度快，性能好
    5. 与互斥锁的区别
        1. 互斥锁会让等待线程进入睡眠状态

14. CAS在什么地方用到过吗？

    1. 定义
        1. 比较并替换 CompareAndSwap,
        2. 执行指令时，当且仅当内存地址V与预期值A相等，将V的值修改成B，否则什么都不做
    2. 场景
        1. 高并发环境下对同一个数据进行并发读(都读100)和并发写(一个写20，一个写30)导致的数据不一致问题
            1. 解决方案
                1. 在set写回的时候加上初始状态的条件Compare，只有不变时才允许写回

15. 谈谈IO多路复用

    1. 是一种同步IO模型，实现一个线程可以监视多个文件句柄。多指网络连接，复用指同一个线程

    2. 三种实现方式

        1. select

        2. poll

        3. epoll

        4. 区别

           |        | 最大连接数         | FD剧增后的IO效率                                           | 消息传递方式 |
                     | ------ | ------------------ | ---------------------------------------------------------- | ------------ |
           | select | 有FD_SETSIZE宏定义 | 线性下降                                                   | 内核拷贝     |
           | poll   | 没有限制           | 同上                                                       | 同上         |
           | epoll  | 有上限但很大       | 活跃socket较少时没有线性下降；活跃socket过多时会有性能问题 | 共享内存     |

### 操作系统-网络 (大多作了解)

1. 介绍域名解析成IP的过程

    1. 检查浏览器缓存是否有对应IP地址
    2. 若浏览器缓存中没有，检查本机系统是否缓存过
    3. 向本地域名解析器发起解析请求
    4. 向根域名解析服务器发起解析请求
    5. 根域名解析服务器返回gTLD域名解析器地址
    6. 向gTLD发起解析请求
    7. gTLD服务器接收并返回Name Server服务器
    8. Name Server返回IP地址给本地服务器
    9. 本地域名服务器缓存解析结果

   简单版：

    1. 检查缓存
    2. 向服务器发起请求
    3. 服务器返回解析结果
    4. 本地浏览器缓存结果

2. 如何在Linux上配置一个IP地址，如果给定端口号如何解析出域名？

    1. 配置Linux系统IP地址
        1. ifconfig
            1. 重启后失效
        2. setup
            1. 永久生效
        3. 修改网卡配置文件
            1. 自动获取
            2. 手动配置
    2. 使用dig命令

3. 解释一下IP地址、子网掩码、网关

    1. IP地址
        1. 有一个32位连接地址，4个8位字段组成，每个8位字段逗号隔开
        2. 包含两部分
            1. 网络ID
                1. 标识在同一个物理网络上的所有宿主机
            2. 主机ID
                1. 标识网络上的每一个宿主机
    2. 子网掩码
        1. 屏蔽IP地址的一部分，使TCP/IP区别网络ID和宿主机ID
        2. 子网掩码位数越多，子网越多，宿主机较少
        3. 对应于网络ID的所有位置为1，对应于宿主机的所有位置为0
    3. 网关
        1. 一个网络连接到另一个网络的关口
        2. 实质上是一个网络通向其他网络的IP地址

4. 说说IP如何寻址？

   //未完善

    1. 本地网络寻址
    2. 非本地网络寻址

5. 操作系统的地址有几种？

    1. 物理地址
    2. 逻辑地址
    3. 线性地址

6. Linux静态地址怎么配置

    1. 编辑etc/sysconfig.network-scripts/下ifcongig开头的文件
    2. 重启网络服务

7. DNS用了哪些协议？

    1. 在区域传输的时候TCP，其他时候UDP
        1. 为什么TCP和UDP同时使用
            1. DNS查询超过512字节的时候必须TCP
            2. 域名解析时消耗少，用UDP使DNS服务器负载低
            3. 区域传送时TCP，保证数据准确性

## 计算机网络

1. 七层网络体系结构

    1. 物理层
    2. 数据链路层
    3. 网络层
    4. 传输层
    5. 会话层
    6. 表示层
    7. 应用层

2. 五层网络体系结构

    1. 应用层
    2. 运输层
    3. 网络层
    4. 数据链路层
    5. 物理层

3. 了解网络编程协议吗？客户端发送给服务端的请求怎么确定协议？

    1. 根据统一资源定位符(URL)确定
    2. 网络编程协议
        1. HTTP
        2. FTP
        3. Gopher
        4. File
        5. HTTPS

4. TCP、HTTP、FTP分别属于那一层

    1. 传输层、应用层、应用层

5. TCP简介

    1. 面向连接全双工，可双向传输
    2. 报文结构
        1. 序号、确认号、首部长度、标志字段、接收窗口

6. HTTP简介

    1. 特性
        1. 支持C/S架构
        2. 快速简单
        3. 无连接、无状态
    2. 客户机和服务器
        1. 客户机：web浏览器
        2. 服务器：web服务器，包含web对象
    3. 方法字段
        1. GET
        2. POST
        3. HEAD
        4. PUT
        5. DELETE
    4. HTTP状态信息
        1. 300-399
            1. 301：被请求的资源已永久移动 永久重定向
            2. 302：临时重定向
        2. 400-499
            1. 400：请求存在语法错误
            2. 403：访问被服务器拒绝
            3. 404：没有找到请求资源
        3. 500-599
            1. 500：服务器发生错误
            2. 503：服务器超载或维护，无法处理请求
    5. 常见文件格式
        1.  text/html： HTML格式
        2.  text/plain：纯文本格式
        3.  image/jpeg：jpg图片格式
        4.  application/json： JSON数据格式
        5.  application/x-www-form-urlencoded： form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据格式）
        6.  multipart/form-data： 在表单中进行文件上传时使用

7. FTP简介

    1. 使用两个并行的TCP连接传输文件
        1. 控制连接
            1. 持久，传输控制信息
        2. 数据连接
            1. 非持久，传输实际文件

8. 讲一下TCP/IP协议

    1. 指能在多个不同网络间实现信息传输的协议簇，不只是TCP和IP
    2. 组成
        1. 应用层
        2. 传输层
        3. 网络层
        4. 链路层
    3. 特点
        1. 完全开放，免费使用
        2. 独立于硬件系统
        3. 网络地址统一分配
        4. 可提供多种可靠网络服务

9. 介绍一下TCP三次握手

    1. 第一次
        1. 建立连接时客户端发送syn包到服务器等待回应
    2. 第二次
        1. 服务器收到syn包，确认并发送syn包
    3. 第三次
        1. 客户端收到服务器syn+ack，向服务器发送确认包。两端进入连接状态

10. 介绍一下tcp四次握手

    1. 客户端向服务端发送FIN控制报文
    2. 服务端收到FIN，回复ACK
    3. 客户端收到FIN，回复ACK到服务端
    4. 服务端收到ACK，链接关闭

11. TCP抓包的理解

    1. 指通过抓取计算机访问Web网站过程抓到的数据包

12. 介绍一下TCP和UDP区别(面试真题)

    1. 连接：TCP面向连接的传输层协议，即传输数据之前必须先建立好连接；UDP无连接。
    2. 服务对象：TCP点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。
    3. 可靠性：TCP可靠交付：无差错，不丢失，不重复，按序到达；UDP尽最大努力交付，不保证可靠交付。
    4. 拥塞控制/流量控制：有拥塞控制和流量控制保证数据传输的安全性；UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。
    5. 报文长度：TCP动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的；UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。
    6. 首部开销：TCP首部开销大，首部20个字节；UDP首部开销小，8字节（源端口，目的端口，数据长度，校验和）。
    7. 适用场景（由特性决定）：数据完整性需让位于通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

13. TCP和UDP优缺点？

    1. TCP
        1. 优点：可靠、稳定
        2. 缺点：慢、效率低，占用资源高、易被攻击
    2. UDP
        1. 优点：快，安全
        2. 缺点：不稳定

14. 如何让UDP稳定一些？

    1. 提供超时重传
    2. 提供确认序列号

15. http和https的区别(面试真题)

    |       | 连接方式     | 端口 | 安全     |
        | ----- | ------------ | ---- | -------- |
    | HTTP  | 无状态       | 80   | 明文传输 |
    | HTTPS | SSL+HTTP加密 | 443  | SSL加密  |

16. HTTP基于TCP还是UDP？

    1. TCP

17. HTTP2.0和HTTP3.0有什么区别

    1. 前者tcp，后者udp

18. 介绍一下HTTP协议中的长连接和短连接。

    1. 短连接是指一次http通信完成后，就会关闭TCP连接．
    2. 长连接是指在一次http通信完成后，不会立即关闭TCP连接，只需要建立一次 TCP 连接就能进行多次 HTTP 通信．

19. 重定向和转发的区别？

    1. 请求次数
        1. 重定向至少2次
    2. 地址栏
        1. 重定向地址栏变化
    3. 共享数据
        1. 重定向不共享
    4. 发生行为
        1. 重定向是客户端，转发是服务端
    5. 跳转限制
        1. 重定向可跳转任意url，转发只能本站资源





# 面试哑火题

1. 垂直分表和水平分表具体怎么操作？
2. redis有用过吗？
3. 中间件用过哪些？
4. mybatis用的是什么代理？
5. 对异常是怎么处理的
