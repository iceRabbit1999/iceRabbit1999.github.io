

#RFC3261

[SIP文档](http://www.kamailio.org/docs/tutorials/sip-introduction/)


## SIP简介

1. 会话初始协议 Session Initiation Protocol
2. 一个**应用层控制(**信令)协议
3. 用于**创建、管理、控制和维护**会话
4. SIP不是垂直的通信系统，是一个可以和其他IETF协议一起使用的组件，用于构建完整的多媒体架构，但是，**SIP的基本功能和操作不依赖于任何这些协议**
5. SIP不提供服务，相反，SIP提供可用于实现不同服务的基元(primitives)
6. SIP提供一套安全服务，包括拒绝服务预防、身份认证、完整性保护以及加密和隐私服务

补充：

1. 信令：是指为使通信网中各种设备协调运作，在设备之间传递的有关控制信息。它用来说明各自的运行情况，提出对相关设备的接续要求。
2. 会话：包括互联网电话、多媒体分发和多媒体会议。

## 简单示例

1. required header

   | 字段           | 属性                                                         |
   | -------------- | ------------------------------------------------------------ |
   | Via            | 1. 包含对此请求的响应的地址<br />2. 包含标识次事务的分支参数 |
   | To             | 1. 包含一个显示名称<br />2. 包含指向的SIP或SIPS URI          |
   | From           | 1. 包含一个显示名称<br />2. 包含指向的SIP或SIPS URI<br />3. 包含一个tag(随机String)用于识别 |
   | Call-ID        | 1. 此呼叫的唯一标识符，由随机字符串和主机名/IP地址组合生成<br />2. Call-ID+To+From组合起来完全定义SIP关系，即对话 |
   | Cseq           | 包含整数和方法名称，每个新请求的Cseq编号会递增               |
   | Contact        | 1. 包含SIP/SIPS URI，全限定域名或IP地址组成<br />2. 告诉其他元素将来发送新的请求的地址(与Via相反) |
   | Max-Forwards   | 用于限制请求在达到目的地的路上可以进行的跳数(最大转发数)     |
   | Content-Type   | 包含消息正文的描述                                           |
   | Content-Length | 包含消息正文的字节计数                                       |

2. SIP消息的主体包含以某种其他协议格式编码的会话描述，一种这样的格式是SDP。SDP类似于有电子邮件承载的文档附件/HTTP消息中携带的网页

## SIP结构

1. 层次结构
   1. 底层是语法和编码
   2. 第二层是传输层
      1. 定义了客户端如何发送请求和接受相应，以及服务器如何通过网络接收请求和发送响应
      2. 所有SIP元素都包含传输层
   3. 第三层是事务层 transaction layer
      1. transaction是SIP的基本组成部分
      2. 事务层处理重新传输，请求和响应匹配，超时
      3. UAC完成的任何任务都使用一系列事务进行
   4. 事务层之上是事务用户(TU)
      1. 除无状态代理之外的每个SIP实体都是事务用户
2. SIP元素，即用户代理客户端和服务器(UAC,UAS)、无状态代理、有状态代理、注册商包含一个核心区别：除了无状态代理之外，都是事务用户
3. UAC和UAS
   1. UAC和UAS核心的行为取决于方法，但有一些通用的规则
   2. 对于UAC，这些规则规定了请求的构造，管理请求的构建
   3. 对于UAS，这些规则管理请求的处理和响应的生成；处理注册的UAS被叫做registrar

## 一些定义

1. 记录地址 Address-of-Record
   1. 记录地址是SIP或SIPS URI
   2. 指向具有位置服务的域，位置服务可以完成URI映射
   3. 记录地址(AOR)常被认为公共地址
2. 背靠背用户代理 Back-to-Back User Agent
   1. 一个逻辑实体，接收请求并将其作为UAS进行处理
   2. 维护对话状态，并且必须参与已建立的对话框上发送的请求
   3. 是UAC和UAS的串联，其行为不需要明确的定义
3. Cal 呼叫 
   1. 对等体之间的某些通信，通常为了多媒体对话设置
4. Call Stateful 调用有状态
   1. 若代理保留从发起INVITE到终止BYE请求的对话状态，则代理是调用有状态的
   2. 调用有状态代理始终是事务状态，但反过来不一定成立
5. Client 客户端
   1. 发送SIP请求并接收SIP响应的元素
6. Conference 会议
   1. 包含多个参与者的多媒体会议
7. Core 核心
   1. 指定特定类型的SIP实体的特定功能
8. Dialog 对话框
   1. 两个UA之间的对等SIP关系
   2. 持续一段时间，通过SIP消息建立对话
9. Downstream 下游
   1. 事务中的消息转发方向
   2. 指向从UAC流向UAS的方形
10. Final Response 最终响应
    1. 终止SIP事务的响应，不是临时响应
    2. 所有2xx，3xx，4xx，5xx和6xx的回复都是最终的
11. Header
    1. SIP消息的一个组件
12. Header Field
    1. Header的组成部分
13. Header Field Value 标题字段值
14. Home Domain 主域
    1. 为SIP用户提供服务的域
    2. 通常是注册记录地址中URI存在的域
15. Informational Response 信息响应
    1. 与临时响应相同
16. Caller 发起者，呼叫者
    1. 发起IINVITE请求会话的一方
17. Callee 受邀者，被叫方
    1. 收到INVITE请求以建立新会话的一方
18. Location Service 位置服务
    1. SIP重定向或代理服务器使用位置服务获取有关被叫方可能位置的信息
    2. 包含一个记录地址密钥与0/多个联系地址的绑定列表
19. Loop 循环
    1. 到达代理的请求被转发，然后回到同一代理；第二次到达时其Request-URI与第一次相同，且影响代理操作的其他头字段不变，因此**代理将对它第一次做出的请求做出相同的处理决策**。
    2. 循环请求是错误
20. Loose Routing 松散路由
    1. 如果代理遵循本规范中用于处理Route头字段的过程，称代理是松散路由
21. Message 消息
    1. SIP元素之间作为协议的一部分发送的数据
    2. 请求或响应
22. Outbound Proxy 出站代理
    1. 一个代理接收来自客户端的请求，即时它不是Request-URI所解析的服务器
23. Parallel Search 并行搜索
    1. 代理在收到传入请求时向可能的用户请求发出多个请求
    2. 并行搜索是在不等待先前请求结果的情况下发出请求
24. Provisional Response 临时响应
    1. 服务器用于指示进度但不终止SIP事务的响应(1XX)
25. Proxy 代理服务器
    1. 一个中介实体，既是服务器又是客户端
    2. 代表其他客户提出请求，路由作用
    3. 主要工作是确保一个请求被发送到离目标更近的另一个实体
26. Recursion 递归
    1. 当一个用户产生一个新的请求到联系头中的一个或多个URI时，就会在一个3XX响应上进行复查
27. Redirect Server 重定向服务器
    1. 一个用户代理服务器，对收到的请求生成3XX响应，指示客户端联系另一组URI
28. Registrar 注册器
    1. 接收REGISTER请求并将其中的信息放入位置服务
29. Regular Transaction 常规事务
    1. 使用INVITE,ACK,CANCEL以外的方法的所有事务
30. Ringback 回铃
    1. 主叫方应用程序产生的信令音，表示被叫方正在被振铃
31. Route Set 路由集
    1. 有序SIP或SIPS URI的集合，表示在发送特定请求时必须遍历的代理列表
32. Sequential Search 顺序搜索
    1. 只有前一个联系地址生成最终响应之后才进入下一个地址
33. Session 会话
    1. SDP规范：多媒体会话是一组多媒体发送器和接收器以及从发送器流向接收器的数据流
34. SIP Transaction SIP事务
    1. 发生在客户端和服务器之间，包括从客户端发送到服务器的第一个请求的所有消息到最终响应
35. Spiral 螺旋
    1. 一种SIP请求，被路由代理继续转发，并再次到达该代理
    2. 不同的方式将导致不同的处理决定
    3. 螺旋不是错误条件，与循环不同，（**请求针对的是不同的用户**）
    4. 一个例子是呼叫转移
36. Stateful Proxy 有状态代理
    1. 在处理请求期间维护由此规范定义的客户端和服务端事务状态的逻辑实体
    2. 也称为事务状态代理
37. Stateless Proxy
    1. 在处理请求期间不维护由此规范定义的客户端和服务端事务状态的逻辑实体
38. Strict Routing 严格路由
    1. 遵循RFC2345的路由处理规则
39. Target Refresh Request 目标刷新请求
    1. 在对话框中发送目标刷新请求被定义为可以修改对话框的远程目标请求
40. Transaction User 事务用户
    1. 驻留在事务层之上的协议处理层
    2. 包括UAC核心，UAS核心和代理核心
41. Upstream 上游
    1. 事务中消息转发方向
    2. 指的是响应从用户代理服务器返回到用户代理客户端的方向
42. User Agent Client UAC 用户代理客户端
    1. 创建新请求的逻辑实体，使用客户端事务状态机制发送
    2. UAC角色仅持续该事务的持续时间
43. UAC Core UAC核心
    1. 位于事务和传输层之上的UAC所需的一组处理功能
44. User Agent Server UAS 用户代理服务器
    1. 生成对SIP请求的响应的逻辑实体
    2. 仅持续事务持续时间
45. UAS Core UAS核心
    1. 位于事务和传输层之上的UAS所需的一组处理功能
46. User Agent UA 用户代理
    1. 充当用户代理客户端和用户代理服务器的逻辑实体



## SIP 消息

1. SIP是一种基于文本的协议，使用UTF-8字符集
2. SIP消息时从客户端到服务器的请求或是从服务器到客户端的响应
3. 消息包含一个起始行，一个或多个标题字段，一个空行表示标题字段结尾，一个可选字段消息正文

###请求

1. 有一个Request-Line作为起始线
   1. Request-Line包含一个方法名称、一个Request-URI、一个由空格分隔的协议版本
   2. 以CRLF结束(CR回车，LR换行)，不允许CR或LF
   3. 除了CRLF序列，任何元素不允许有线性空白(任意数量的空格或水平制表符)
   4. **Request-Line = Method SP Request-URI SP SIP-Version CRLF**
2. Request-URI
   1. SIP或SIPS URI
   2. 不能包含非转义空格或控制字符，不得包含在“<>”中。
3. SIP-Version
   1. 请求和响应消息都包括正在使用的SIP版本

###响应

1. 状态行为起始线
   1. 包括协议版本，后跟数字状态码及关联短语，每个元素由空格分隔
   2. 除最终的CRLF序列，不允许使用CR或LF
   3. **Status-Line = SIP-Version SP Status-Code SP Reason-Phrase CRLF**
2. Status-Code
   1. 是一个3位整数结果代码，指示请求的结果
3. Reason-Phrase
   1. 提供Status-Code的简短文本描述
   2. 客户端不需要检查，只是为了让人看懂

###Header Fields

1. header = "header-name" HCOLON header-value *(COMMA header-value)
2. Header Field Format
   1. field-name: field-value（类似yml 字段: 属性  --冒号后接空格）
3. 标题字段始终不区分大小写，除非特殊说明，带引号的字符串值区分大小写

## UAC行为

###生成请求

1. 由UAC指定的有效SIP请求需要至少包含六个字段
   1. To
   2. From
   3. Cseq
   4. Call-ID
   5. Max-Forwards
   6. Via

####Request-URI

1. 消息的初始Request-URI应该设置为To字段中URI

###发送请求

###处理响应

1. 响应首先被传输层处理，并传递到事务层，事务层处理完后再传递到TU
2. TU层主要处理方法相关出

####事务层错误

1. 某些情况下从事务层返回的响应不是一个SIP消息，而是一个错误
2. 事务层收到超时错误的时候，必须将其视为收到408(请求超时)，收到致命错误时，必须将其视为503(服务不可用)

####未知响应

1. UAC必须把自己不认识的所有最终应答当作X00类响应
2. 一个UAC必须能处理100和183响应

####Vias

1. 如果响应中不止一个Via，UAC应该丢弃这个消息
2. 包含超过一个Via头域值的消息是因为被错误的路由或者消息被破坏

####处理3XX响应

1. 接收到3XX重定向响应，客户端应该使用Contact头字段中的URI，根据重定向请求指定一个或多个新请求
2. 具体流程
   1. 。。。

####处理4XX响应

1. 要求特定的UA处理，和请求的方法无关
2. 401(未授权) /407(Proxy认证需要)
   1. 重新发送带认证信息的请求
3. 413(请求过大)
   1. 尝试retry或去掉包体或者换一个小一点的长度
4. 415 不支持的媒体类型
   1. 重发请求且只包含Accept头域指明的媒体类别，并对应好encoding方法和语言
5. 416 不支持的URI
   1. 尝试retry并换用SIP URI
6. 420 非法扩展
   1. 尝试去掉响应中Unsupported头域中列出的扩展并retry
7. 所有需要重试的请求，都需要经过适当修正成为一个新的请求。这个新请求采用一个新的transaction并且应该有和上次请求相同的Call-ID,TO,From头域

## UAS行为

​	请求的处理是**原子级别**的。如果请求被处理，那么这个请求的相关状态一定是其更新的；如果被拒绝，一定是没有改变的

###方法判定

1. UAS首先判断请求的方法
   1. 自己不能处理，给出405响应(方法不支持)，并在405响应中增加一个Allow头域，声明支持哪些方法、
   2. 支持该方法，处理继续

###Header判断

1. UAS不认识请求的头字段，必须忽略该头字段并继续处理该消息，即UAS应
   该忽略处理请求不必要的任何格式错误的头字段

####To和Request-URI

1. To域值包含了原始接收者(不一定是最终处理请求的UAS)，**当To域值与UAS自身不相符时，可以由UAS自身决定是否接收请求**，建议的做法是处理；如果拒绝，应该产生403状态码并交给事务层
2. Request-URI
   1. 确定UAS来处理请求，如果Request-URI使用了一个不支持的方案，应当拒绝这个请求并给出416状态码
   2. 如果Request-URI没有指明由本UAS处理，则应该给出404响应

####Merged Requests 合并请求

1. 如果请求的To头域没有taag标志，UAS核心必须检查基于正在进行的事务请求
2. 如果接受到的请求和正在处理的请求的From,Tag,Call-ID,Cseq精确匹配，但请求并不匹配事务，核心要产生482并发送给服务器的事务层
3. 相同的请求通过不同的路径到达UAS，通常情况下是由于分支的原因，UAS处理第一个请求并给其他所有这个请求482响应

####Require 要求

1. 如果请求的各项要素通过了UAS的判定，且存在Require头域，下一步就是检查Require头域
   1. Require头域是UAC用来通知UAS应该用什么样的SIP扩展来处理本请求
2. 如果UAS不支持Require头域中的option-tag列表，必须产生一个420响应，且为请求加上Unsupported头域，声明Require头域中哪些是自己不支持的
3. Require和Proxy-Require禁止出现在SIP CANCEL请求中，或者回应给非2XX应答的ACK请求中；就算出现了也应该被忽略
4. 对2XX响应的ACK请求必须仅包含初始请求中存在的Require和Proxy-Require值

###Content Processing 内容处理

1. 当UAS支持客户端请求中要求的扩展后，要检查消息头域描述的消息体部分
2. 如果UAS不支持Content-Type,Content-Language,Content-Encoding，且这个消息体并非可选的消息体，则必须回应一个415错误响应；且必须加上一个Accept头域，对应声明不支持具体哪一项

###Applying Extensions 应用扩展

1. 如果UAS希望应用一部分SIP扩展，不可以在产生响应的时候做SIP扩展(除非该扩展在请求中国的Suppotred头域中声明)
2. 极少情况下，服务端不用扩展就无法处理请求，应该产生421响应

###Processing the Request 处理请求

1. 当所有检查都通过后，UAS根据方法决定如何处理请求

###Generating the Response 产生响应

需要遵循一定的步骤；完成响应后，UAS把响应交到收到请求的服务器事务层处理

####发送一个临时响应

1. 非INVITE请求的情况下，UAS不应该发送临时响应给请求者，若发送了临时响应，也应该尽快发送最终响应
2. 如果产生一个100响应，请求中如果有Timestamp，响应中也必须有，如果响应有延时，UAS应该在Timestamp上增加延时的值

####Headers和Tags

1. 应答中的TO、From、Call-ID、Cseq、Via(包括顺序)必须和请求中相同
2. 如果请求中的To头域不包含Tag，那么应答中的To头域URI必须和请求相等
3. UAS必须增加一个Tag在To头域(100响应是一个例外)

###Stateless UAS Behavior  无状态UAS行为

1. 无状态UAS是不保持事务状态的UAS
   1. 会回复请求，但会丢弃在发送响应后通常UAS保留的任何状态
   2. 如果无状态UAS接收到一个重新发送的请求，会重新产生应答并重新发送(就像新请求而不是重发请求)
   3. 只有当相同请求的处理会导致相同应答的时候这个UAS才是无状态的
   4. 无状态的UAS不包含事务层，直接从传输层接收和发送请求与应答
   5. 无状态UAS通常用于处理不需要身份认证的请求且这些请求的应答是可以预期的
      1. 大量不需要身份认证的请求被作为有效UAS处理会导致DoS状态
   6. 无状态UAS的特性：
      1. 不允许发送临时响应 1XX
      2. 必须忽略ACK请求
      3. 必须忽略CANCEL请求
      4. To头域必须依据无状态的规则产生(对于相同的请求产生相同的Tag标记)
   7. 对于一个新请求来说，UAS可以是有状态的也可以是无状态的



##  Redirect Servers 重定向服务器

1. 某些架构中可以通过重定向机制来降低Proxy服务器上的路由请求压力，从而提高转发效率
2. 重定向允许服务器在一个请求的应答中，推送路由信息到客户端(把自己从后续的消息流中脱离出来，同时又能提供准确的位置服务)，当请求发起者收到转发的应答之后，会重新产生一个基于接收到的URI请求
3. 转发服务器在逻辑上通过一个服务器的事务层建立，它作为TU访问某些类型的位置服务，该位置服务可以用数据库里边的一个URI对应多个地址URI实现
4. 一个重定向服务器并不发出任何指向自己的请求
5. 接收到任何一个非CANCEL请求后，服务器要么拒绝，要么从位置服务器上找到这个请求应该去的其他位置并返回3XX的终极响应
6. 对于合法CANCEL请求，应该返回2XX响应，该响应会终结掉SIP事务
7. 重定向服务器返回3XX响应
   1. 会在Contact头填写一组其他位置信息
   2. 需要指明Contact数据的生存周期，可以再Contact头域添加一个expries参数
      1. expries以秒为单位
   3. Contact头域包含指向其他新位置的URI或用户名或附加通讯参数
8. 重定向服务器绝对不能重定向一个请求到自己的Request-URI列表中的地址
9. 若客户端使用出站Proxy，且这个Proxy实际上是重定向请求，有可能出现无限重定向循环
10. 重定向服务器必须忽略自己所不能理解的功能

## 取消一个请求 Canceling a Request

1. CANCEL请求是用来取消客户端发起的上一个请求
   1. 比如请求UAS终止上一个请求并产生一个错误响应
2. CANCEL对UAS已经给出终结响应的请求无效
   1. 所以CANCEL的最大用处是取消需要服务器长时间处理的请求(INVITE)
3. CANCEL可以由Proxy或UAC发起
4. 一个有效状态的Proxy需要对CANCEL作出响应，而不是简单地转发从下游中收到的一个应答
   1. CANCEL是一个点对点请求，即需要一个有状态的proxy节点进行处理和应答

### 客户端行为 Client Behavior

1. CANCEL不应该取消除了INVITE以外的任何请求，因为非INVITE请求都是即时响应的
   1. CANCEL取消非INVITE请求会形成赛跑：CANCEL先到还是被取消的请求先到
2. 创建CANCEL请求的步骤
   1. CANCEL请求中的Request-URI,Call-ID,To,Cseq的数字部分以及From头字段必须与被取消的请求相同，包括标签
   2. 客户端构造的CANCEL请求必须只有一个Via头字段且要与被取消请求的顶部Via匹配
   3. 如果被取消的请求包含Route头字段，CANCEL也必须包含Route头字段的值(这样无状态代理才能正确路由)
   4. CANCEL请求不得包含任何Require或Proxy-Require标头字段
3. 一旦CANCEL请求被创建，客户端应当检查是否收到CANCEL要取消的原始请求的任何应答(临时或最终)
   1. 如果没有任何应答，这个CANCEL请求一定不能发送，直到客户端等到第一个临时应答
   2. 如果已经收到一个终结应答，这个CANCEL也不应该发送
4. 客户端发送一个CANCEL，会为这个CANCEL请求创建一个客户端事务并通过目的地址、端口、传输层(必须和原始请求一样)来发送请求
5. 如果允许在接收应答之前发送CANCEL请求，那么服务端必须支持接收原始请求之前收到CANCEL请求
6. 原始请求的事务和CANCEL请求的事务都是互相独立的

### 服务端行为 Server Behavior

1. CANCEL请求要求服务端的TU取消相关的事务
2. TU通过接收CANCEL请求来确定要取消的交易，然后假设请求方法不是CANCEL或ACK
3. 服务端对CANCEL请求的处理依赖于服务器的类型
   1. 一个无状态的Proxy会转发
   2. 一个有状态的Proxy可能会响应并且自己再产生一些CANCEL，UAS会响应这些CANCEL
4. CANCEL请求不能反复提交尝试，也不能包含Require头域
5. 若UAS找不到CANCEL请求匹配的事务，应该给一个481响应，若事务存在，则
   1. 若已经对原始请求发出了最终响应，不对其做任何处理
   2. 若没有对原始请求作最终响应，则依赖于原始请求的方法
      1. 若原始请求是INVITE，UAS应当立即响应一个487
      2. 本协议对其他方法没有约定
6. 不管原始请求的方法是什么，只要CANCEL匹配一个事务，UAS就响应一个200

## 注册 Registrations

### 概览

1. SIP提供了一个搜索机制：若一个用户希望建立和其他用户的会话，SIP必须能够查找到对方用户正在使用的主机
2. SIP部件考虑了一个抽象的服务：位置服务
   1. 通过对特定地区提供地址绑定来实现
   2. 基本上一个Proxy会从把输入的URI转换到用户实际位置的位置服务得到用户最终位置
   3. 有很多方法建立位置服务，一种是administratively
3. 注册服务为特定地区的位置服务创建**绑定关系**
   1. 这个绑定关系用来建立包含一个或多个联系地址的address-of-record URI
   2. Proxy接受到一个请求，请求的Request-URI和address-of-record URI的记录匹配，则这个Proxy会转发该请求到登记的联系地址(AOR)中去
4. SIP提供了一个让UA能够创建精确绑定的机制——登记服务
5. 登记服务需要向一个特殊的UAS服务器(registrar)发出REGISTER请求
   1. registrar为一个区域的位置服务作为前端接入，根据REGISTER请求的内容读写位置对照表
6. registrar和proxy都是逻辑角色，可以在网络中用一个设备来部署
7. SIP本身对实现位置服务器(Location Service)没有特别要求
   1. 唯一的要求是某些区域的registrar必须能够对位置服务的数据进行读写且这个区域的proxy或重定向服务器必须能够兼容读取相同数据

### 构造一个REGISTER请求

1. REGISTER请求用来增加、删除、查询绑定
2. 一个REGISTER请求并不建立一个对话
3. UAC不能基于REGISTER请求的应答中的任何Record-Route头域来创建新的路由集合
4. 一个REGISTRT请求必须包含的字段
   1. Request-URI
   2. To
   3. From
   4. Call-ID
   5. Cseq
5. Contact为可选字段
6. UA在没有收到上一注册请求的应答或上一注册请求超时之前，禁止发送新的注册请求(包含一个新的Contact头域而不是重发)
7. Contact头域参数在REGISTER请求中的特别意义
   1. acton
      1. 已被废弃，UAC不能使用
   2. expires
      1. 表明UA绑定的有效时间，以秒为单位

#### 增加绑定

1. REGISTER请求是向registrar发送一个包含对某一个address-of-record的地址的SIP请求应当发送的实际联系地址
   1. address-of-record包含在REGISTER请求的To头域中
2. 如果ADR是一个SIPS，那么任何在REGISTER请求中的Contact头域都应该是SIPS URI

##### 设置Contact地址的过期参数

1. 客户端设置有效期的方法
   1. 设置Expires头域
   2. 设置Contact头域的expires参数
      1. 允许同一个REGISTER请求中的多个绑定联系地址中的每一个联系地址单独设定
   3. 如果都不设置，表明有效期由服务器决定

##### Contact Adress参数选择

1. 如果REGISTER请求中包含多个Contact，说明UA想把些Contact头域的内容和To头域中制定的ADR地址绑定
   1. 这个列表可以用q参数区分Contact头域的优先级

#### 删除绑定

1. 注册信息是一个纯粹的软件状态，如果不刷新会过期；如果需要也可以删除
2. 一个客户端可以通过发出有效期为0的REGISTER请求，使某一个联系地址立即失效(UAS都需要实现这个机制使得在联系地址过期前能够被删除)
3. REGISTER规范中Contact头域可以设置为*，但只能在删除所有的注册项的时候使用(这样UA就不用知道每一个注册项的精确值)

#### 访问绑定

1. 无论请求是否包含Contact头域，对其成功过的应答都包含了一个完整的绑定列表
2. 如果REGISTER请求不包含Contact，绑定列表将不会改变

#### 刷新绑定

1. 每一个UA都对先前建立的绑定信息有刷新的义务且禁止对其他UA建立的绑定进行刷新
2. 在registrar给出的200响应中包含了Contact中列明的当前绑定信息，UA需要挨个比较这些联系地址，判断是否可以建立联系
   1. 能建立联系，通过expires参数更新过期时间(或Expires)。于是在过期前UA为每个绑定发出REGISTER来刷新绑定
   2. 在一个刷新周期中，应该使用相同的Call-ID进行注册调用，刷新的注册信息因和原来的登记信息一致

#### 设置内部时钟

1. 如果REGISTER请求的应答中包含一个Date头域，客户端可以用这个头域来校正当前内部的时钟

#### 寻找注册服务器

1. UA有三种方法来决定向哪里发出注册请求：
   1. 通过配置
      1. 一个UA可以使用非文本文档规定的方式配置注册服务器的地址
   2. 使用address-of-record
      1. 没有配置时，UA应该用请求的Request-URI部分中的address-of-record的服务器部分(host part)
   3. 广播方式
      1. 通过监听sip.mcast.net 224.0.1.74
      2. 在某些环境下不能使用

#### 传送一个请求

1. 前置条件
   1. REGISTER请求被构造好
   2. 有了登记服务器的地址
2. UAC提交事务层来发送REGISTER
3. 如果transaction层返回一个由于REGISTER请求没有应答的超时错误，UAC不应该立刻重新尝试对同一个注册服务器的注册请求。(立刻重新尝试很有可能导致再次超时)

#### 错误响应

1. 如果UA接收到一个423(间隔太简略)可能需要更改REGISTER请求中的有效期并尝试retry

### 处理REGISTER请求

1. 一个registrar本身就是一个UAS，只不过该UAS用来响应REGISTER的请求且维持一个绑定表，该绑定表用来提供它管理的区域的proxy和重定向服务器
2. registrar禁止产生6XX响应
3. registrar可以适当转发REGISTER
4. registrar必须忽略REGISTER请求中的Record-Route头域且不能在相应总包含任何的Record-Route头域
   1. 注册器可能会收到遍历代理的请求，该代理将REGISTER视为未知请 求并添加了Record-Route头字段值。
5. registrar必须知道所管理的区域，一定按照接受到的REGISTER顺序进行处理
6. REGISTER请求必须当作原子请求来处理：要么完整处理，要么完全拒绝；每一个请求信息的处理都和其他注册和绑定信息无关
7. registrar收到一个REGISTER请求时：
   1. registrar检查Request-URI来决定是否属于其管理的区域
      1. 若不是，且该registrar同时作为proxy，那么应当转发该请求到指定的位置
   2. 处理Require头域(Header判断)
   3. 对UAC进行身份认证
   4. 检查认证的用户是否通过认证来更改address-of-record的登记权限(权限管理)
   5. 从To头域中解出address-of-record
      1. 若该ADR在Request-URI指明的区域中是非法的，给出404并跳过后续步骤；接着URI必须转换成标椎格式
   6. 检查请求是否包含了Contact头域
      1. 若没有，跳到最后一步
      2. 若有
         1. 检查是否有一个Contact头域值是*且包含了一个Expires头域
         2. 检查是否有其他Contact头域或任何有效期的值是非0的
            1. 若有，该请求是非法请求，服务器送回400，跳过后续步骤
            2. 若没有，检查是否Call-ID符合每一个绑定的值
               1. 不符合，删除绑定
               2. 符合，仅删除保存的绑定表中Cseq值小于请求中Cseq值得记录；否则必须终止更新，请求失败
   7. 依次处理Contact头域中的联系地址
      1. 对于每一个地址根据以下规则进行有效期检查
         1. 若含有expires参数，这个参数值就是最终的有效期。
         2. 若没有expires且有一个Expires头域，那么这个值就是有效期。
         3. 如果没有Expire头域也没有参数，那么本地的缺省配置应当作为有效期
      2. 响应423错误来拒绝的情况
         1. 当且仅当请求的有效期大于0 并且小于1个小时并且小于一个注册服务器配置的最小有效期的时候
         2. 该应答必须包括一个Min-Expires头域来表明本注册服务器所接收的最小有效期，然后跳过所有后续步骤
      3. 允许注册服务器设置注册服务器自己的有效期防止了过分频繁的刷新注册信息，并且也降低了维持和管理注册信息的工作量
      4. 对于每一个地址registrar在当前绑定列表中用URI规则搜索
         1. 如果绑定不存在，会暂时性添加进去
         2. 如果绑定存在，registrar检查Call-ID的值
            1. 如果Call-ID的值与本次请求的Cll-ID不一样
               1. 如果绑定的有效期为0就删除这个绑定
               2. 否则就刷新这个绑定
            2. 如果Cll-ID的值一样，registrar比较Cseq
               1. 请求中的Cseq比绑定值中的Cseq高，更新或删除这个绑定(取决于有效期)
               2. 请求中的Cseq低，终止更新并请求失败
      5. 上面的规则确保了从同一个UA过来的请求顺序处理，对于非顺序请求跳过处理
      6. 每一个绑定记录都包含当时请求的Call-ID和Cseq值
      7. 只有当且仅当所有的绑定更新和添加都完成，绑定才可以COMMIT，任何更新和添加失败，必须给出500，且所有的中间临时更改都要删除
   8. registrar返回的200必须包含Contact头域，其中列举所有当前绑定的注册信息；每一个Contact都必须包含expires参数和Date头域

## 查询能力

1. OPTIONS允许一个UA查询另外一个UA或者proxy服务器的能力。
2. This allows a client to discover information about the supported methods, content types, extensions, codecs, etc. q且不用振铃对方
3. OPRIONS请求的目标是用Request-URI指明，且可以是UA也可以是SIP服务器和proxy
4. OPTIONS请求可以作为建立会话的一部分，用来查询对方的能力使用

### 构造OPTIONS请求

1. Contact头域为可选
2. Accept应该包含在请求中，用来表示标志UAC希望接收应答中的消息实体的类型
3. 如果在建立会话的时候使用OPTIONS请求，那么OPTIONS之后的这些请求都应该由这个OPTIONS查询的服务器处理，这样才能保证使用的特性和OPTIONS查询出来的能力是一样的

### 处理OPTIONS请求

1. 状态码的选择必须和INVITE请求一样(，200（OK）应当在UAS能够接收请求的时候返回，486（忙）应当在UAS如果忙的时候返回)
   1. 可以用OPTIONS来知道UAS能否接收INVITE请求
2. 如果OPTIONS请求的应答是由proxy服务器给出的，proxy返回一个200（OK）的应答，列出这个服务器的各种选项和能力
3. 200中应该出现的头域
   1. Allow
   2. Accept、Accept-Encoding、Accept-Language
   3. Supported
   4. 如果是proxy产生的200，忽略Allow(proxy是方法无关的)
   5. Contact可以出现，可以列出指向客户的一串名字和方法的集合（用以转发请求）
   6. Warning头域可以出现
   7. 消息体可以被发送，类型由OPTIONS请求的Accept头域指明
   8. 如果Accept头域中包含了一个类型能描述媒体接收能力，UAS应当在应答中包含一个消息体用于这个用途

## 对话 Dialog

1. 对话是UA的核心概念
2. 对话表现为两个UA之间的持续一段时间的点对点SIP关系，可以认为是对SIP消息解释的上下文关系
3. dialog ID
   1. 一个对话在UA中的标记
   2. 由Call-ID、本地tag和远程tag组成；各个UA的dialog ID在对话中不一样
   3. 是唯一的
   4. 和所有To头域中包含了tag参数的请求和应答相关
   5. 填写dialog ID的规则依赖于SIP元素是UAC还是UAS
      1. UAC
         1. dialog ID中的Call-ID的值会填写到消息中的Call-ID域中，远程tag放在消息中的To的tag参数中，本地tag放在From的tag参数中。（这些规则对请求和应答都适用）
      2. UAS
         1. dialog ID的Call-ID值放在消息的Call-ID头域中，远程tag放在From头域的tag中，本地tag放在To头域的tag参数中。
4. 一个对话包含一些特定的状态用于以后的对话中的消息传送
   1. 该状态由dialog ID、本地序列号、远程序列号、本地URI、远程URI、远程tag、一个布尔类型的标记secure、路由组成
   2. early状态
      1. 当这个对话收到了临时应答而创建
   3. confirmed状态
      1. 当收到了2xx终结应答的时候

### 创建一个dialog

1. 对话由一组特定的没有失败的响应创建的
2. 在本规范中，只有包含To tag的2xx和101－199应答，并且请求是INVITE的，会建立一个对话

#### UAS做了什么

1. 拷贝所有的请求中的Record-Route头域到应答中去(无论其认不认识)且维持参数的顺序
2. 增加一个Contact头域给应答，包含一个后续对话请求中接受请求的地址
3. Contact中的URI必须是SIP/SIPS URI
4. 这个URI应该是全局有效的
5. 创建对话状态维持到对话结束
6. 若请求是通过TLS过来的且Request-URI包含SIPS URI， secure将被赋值成TRUE
7. 路由集合设置为请求中的Record-Route的URI列表，保留所有参数和顺序；若请求中没有Record-Route，那么路由集设为空，且覆盖预先存在的路由集
8. 远程序列号设置为请求中的Cseq头域序列号，本地序列号设为空
9. 远程URI（remote URI）必须设置成为From头域中的URI，并且本地URI必须设置成为TO头域中的URI

#### UAC做了什么

1. 发出一个请求，该请求可以建立对话
2. 该请求在Contact头域中提供全局的SIP/SIPS URI
3. 构造对话状态维持到对话结束
4. 若请求是通过TLS过来的且Request-URI包含SIPS URI， secure将被赋值成TRUE
5. 由集合设置为**应答**中的Record-Route的URI列表，保留所有参数和顺序；若请求中没有Record-Route，那么路由集设为空，且覆盖预先存在的路由集
6. 本地序列号设置为请求中的Cseq头域的序列号。远程序列号必须设置成为空
7. 远程URI（remote URI）必须设置成为To头域中的URI，并且本地URI必须设置成为From头域中的URI

### 对话中的请求

1. 两个UA之间的对话建立以后，他们都可以在对话中初始化一个新的事务
2. 在建立对话的事务过程中，UA扮演的角色可能是不一样的。
3. 对话中的请求可以包含Record-Route和Contact头域，虽然他们会修改remote target的URI，但是这些请求也**不会导致对话的路由集被改变**
4. 刷新target请求只会更改对话的remote target URI，并且更改由Record-Route指定的路由集合。

#### UAC做了什么

##### 产生请求

1. 对话中的请求通过许多对话的状态部分构造
2. 请求的Call-ID必须设置为对话的Call-ID；对话中的请求必须严格遵循单个递增的Cseq序列号(除了ACK和CANCEL)
3. 如果本地序列号不为空，那么本地序列号码必须依次增加1，并且这个数值要存放到Cseq头域中，如果本地序列号码是空的，那么约定的初始值必须填写进去
4. 在Cseq头域中的method字段必须和请求的方法（method）一致。
5. 通过使用32位的长整数，使得即使每秒种产生1笔请求，也会要136年才会用完这个整数出现重复；一个客户端可以用31位有符号整数或者32位无符号整数来存放时间作为初始化的序列号
6. UAC使用remote target和路由集合来构造请求中的Request-URI和Route头域。
7. 路由集合
   1. 如果路由集合是空的，那么UAC必须把remote target URI放到Request-URI中，并且UAC不能添加Route头域到请求中。
   2. 如果路由集合不为空，并且路由集合的第一个URI包含lr参数，那么UAC必须填写remote target URI到Request-URI，并且必须包含Route头域，这个Route头域按照顺序填写路由集合和路由集合的参数。
      1. 路由集合的第一个URI没有包含lr参数，那么UAC必须把第一个URI放在Request-URI中，并且拆去所有不被Request-URI允许的参数。UAC必须增加一个Route头域顺序包含所有剩下的路由集合元素，及其参数。UAC接着必须把remote target URI放在Route头域的最后一项。
8. 在对话内的任何一个刷新target的请求中，都应当包含一个Contact头域，并且这个URI除非有必要，否则都应当是和对话内上次请求的URI值一样

##### 处理应答

1. UAC将会从transaction层收到请求的应答
2. 超时等同于408
3. 处理3XX虽然UAC会尝试新的地址，依旧使用对话内的路由集合来构造请求的Route头域。

#### UAS做了什么

1. 对话中发送的请求也是原子请求，UAS从事务层收到请求
2. 请求的To头域有tag字段，UAS拿请求中的tag和现存对话比较
   1. 匹配成功--即在一个对话中的请求，UAS按照对外请求处理
   2. 匹配不成功，UAS可能已崩溃并重新启动或是收到另一个UAS构造的tags或是简单的请求发送错误；此时UAS可以选择接收或拒绝请求
      1. 在允许的情况下下，尽量处理请求
3. 如果UAS由于不希望重构对话而拒绝这个请求，它必须应答对方一个481
4. 对于在对话中接收到的，那些不会用任何形式更改对话状态的请求，比如OPTIONS请求，他们等同于在对话外的处理请求
5. 如果一个proxy废弃掉一个UAC产生的请求，并且UAC重新递交这个请求的时候。这个请求是会具有一个全新的Cseq序列号。UAS是不会收到第一个请求的，这样，Cseq序列号就会出现间隔，这样的间隔并非是一种错误的情况。

### 终止对话

1. 在已经建立的对话中，终结对话就是请求方法相关的。在这个定义中，BYE方法将会终结一个对话

## 初始化一个会话

### 概览

1. 首先构造一个INVITE请求。这个INVITE请求一个服务器来建立一个会话，这个请求可能会由proxy层层转发，最后到达一个或者多个可能能够处理这个邀请的UAS
2. 这些UAS需要看看是否用户接收这个邀请。然后UAS可以接收这个请求（也就是会话建立了），通过发送2xx应答。如果邀请被拒绝，根据拒绝的原因，3xx，4xx，5xx或者6xx应答将会发送。在发送终结应答之前，UAS可以发送一些临时应答（1xx）应答给UAC，以便UAC能够掌握建立会话的进度。
3. 当UAC收到了终结应答，UAC需要给每一个INVITE的终结应答，发送一个ACK请求；送ACK请求的步骤依赖于应答的类别
   1. 对于在300到699的终结应答，ACK是在transaction层处理的，并且遵循一系列规则
   2. 对于2xx应答，ACK是由UAC处理核心产生的

### UAC处理

#### 创建一个初始的INVITE

1. 除开之前的创建对话外请求步骤外，还有针对INVITE的附加处理步骤
2. 在INVITE中应当包括一个Allow头域，用来标志在这个INVITE建立的dialog中什么样的方法可以接受
3. Supported头域应当包含。这个头域包含了所有这个UAC支持的扩展部分
4. UAC可以通过包含一个Expire头域来限制邀请的有效期限；如果Expire头域的时间到了还没有接收到INVITE的终结应答，UAC处理核心产生一个对INVITE请求的CANCEL请求
5. UAC还可以根据需要增加Subject，Organization和User-Agent，这些头域都包含了INVITE的相关资料
6. UAC可以给INVITE增加一个消息体
7. 初始化一个INVITE事务的规则
   1. 初始化请求必须在INVITE中如果不在INVITE请求中，就必须在UAS回送给UAC的第一个非失败的可靠消息中(200)
   2. UAC必须把它接收到的第一个会话描述当作是应答，并且必须忽略任何在初始INVITE请求中后续的会话描述应答描述
   3. 如果初始请求是在第一个可靠的非失败的UAS回送给UAC的消息中，那么应答必须在这个消息的确认消息中
   4. 在发送或者接收到第一个请求的应答之后，UAC可以同样依据这样的问答方法产生后续的请求(不能在上一个请求尚未收到应答的时候发起下一个请求)
   5. UAS在完成初始化的事务之前，不会产生任何会话描述请求。
8. 边的规则分别定义了两种UA之间交换信息的方法
   1. 请求实在INVITE中，应答是在2xx
   2. 请求在2xx中，应答在ACK中

#### 处理INVITE应答

1. INVITE请求被传送给INVITE的客户事务层进行处理，UAS等待INVITE的应答如果INVITE客户事务层返回一个超时，TU应当像收到一个408

##### 1XX应答

1. 有可能在收到一个或者多个终结应答之前，UAC会收到0个或者1个或者多个临时应答
2. INVITE的临时应答会建立”early dialogs”
   1. 如果一个UAC需要在完成初始的INVITE事务之前，给对方发送一个对话内的请求的时候，就需要early dialog
3. 由于Allow是允许的方法集合，所以，当对话状态是早期对话的时候，这个Allow的集合是不会改变的，但是当创建正式的dialog之后，Allow的集合可能会改变

##### 3XX应答

1. 一个3xx应答可能包含一个或者多个Contact头域值，这个头域值提供了被叫方可能存在的地点。UAC可以根据3xx应答的状态码来决定是否尝试这些新的地址

##### 4XX，5XX，6XX应答

1. 在INVITE请求中，可能会收到单个非2xx终结应答。
2. 4xx，5xx，6xx应答如果包含了Contact头域，那么这个头域值指示了错误的详细信息的解释地点。后续的终结应答（只有可能在发生错误的情况下），必须被忽略掉。
3. 所有的早期对话都会由于接收到非2xx终结应答而结束
   1. 一旦接收到了非2xx终结应答，UAC处理核心就认为INVITE事务结束了。INVITE客户事务处理生成对这个应答的ACK

##### 2XX应答

1. 单个INVITE请求可能会导致多个2xx应答返回给UAC
   1. 这是因为proxy可以分支
   2. 每一个应答都是由To中的tag参数来进行区分的，并且每一个应答都代表了一个独立的对话，具备单独的对话ID
2. 2xx应答中的对话ID和一个现存的对话是否匹配
   1. 匹配，这个对话必须切换到”confirmed”状态，并且对话的路由集合必须基于2xx的应答进行重新计算
   2. 不匹配，必须创建一个新的对话，这个对话具备”confirmed”状态
3. 在对话状态中，只有路由集合不需要重新计算
4. 其他部分比如对话内的最大的序列号（远程的和本地的）等都不需要重新计算
5. 当ACK创建以后按照一定的步骤检测对方的地址，端口和transport，这个请求是直接交给通讯层进行通讯
6. 每次收到一个重发的2xx终结应答的时候都必须发送一个ACK到通讯层。
7. 
8. UAC核心认为INVITE事务在接收到第一个2xx应答后的64×T1秒后完成。在这个时间点后，所有没有转换成为建立连接状态的早期对话都会被终止

### UAS处理

#### 处理INVITE

1. UAS核心从事务层收到INVITE请求,按照跟对话内外无关的请求的处理，如果处理顺利完成（没有产生应答），UAS核心根据如下步骤进行额外处理：
   1.  如果INVITE请求包含一个Expires头域，UAS核心就设置一个时钟计数＝这个头域值
      1. 时钟到了，这个邀请就过期
      2. 如果在UAS尚未产生终结应答的时候就超时了，那么487（请求终止）应答应当产生给UAC。
   2.   如果请求是一个对话中的请求，按方法无关的处理步骤将首先进行处理
   3. 如果请求的To头域包含了一个tag，但是对话的ID与现存的任何一个对话都不匹配，将假定这个INVITE是在对话外的
   4. 如果INVITE并没有包含某个会话描述（session description），UAS就是被邀请创建一个会话，UAS必须在它的给UAC的第一个非失败的可靠消息中(200)提供这个offer
   5. UAS可以提示进度，接受，转发，或者拒绝这个邀请

##### 提示进度

1. 如果UAS不能马上接受或者拒绝邀请，那么它可以提示某种形式的进度给UAC（比如提示一个回铃声
   1. 通过一个101到199的临时应答实现
   2. 临时应答建立了早期对话（early dialog
   3. UAS可以发送多个临时应答。每一个临时应答都必须包含相同的dialog ID
2. 如果UAS打算延长一点时间来响应这个INVITE请求，它需要请求一个”extension”来防止proxy来取消这个事务
3. proxy有权利来取消超过3分钟未完成的事务。要防止这个取消，UAS必须每分钟发送一个非100临时应答，防止由于1xx临时应答的非可靠传输导致的临时应答丢失。
4. 如果呼叫处于等待状态或者这个呼叫正在和PSTN电话系统进行通讯，INVITE事务是可以被延长处理时间

##### INVITE请求事务转发

1. 如果UAS决定转发这个呼叫，就需要发出3xx的应答。
2. 应答中应当包含一个Contact头域，这个头域包含了一个或者多个表明需要重试的URI新地址
3. 这个应答交给INVITE服务端事务层，由服务端事务层负责应答的重发

##### INVITE请求拒绝

1. 拒绝INVITE请求的常见情景是被叫方不想或者不能在终端系统上接收这个呼叫
   1. 486（用户忙）应当在这样的情况下返回
2. 如果UAS知道没有其他终端系统能够响应这个呼叫，就应当返回一个600
3. 这些应答是交给INVITE服务端的事务层进行发送的，由这个事务层来保证应答的重发机制
4. 如果UAS拒绝的是INVITE请求包含的媒体磋商offer，UAS应当返回一个488，这个应答应当包含一个Warning头域来解释为何offer被拒绝。

##### 接受INVITE请求

1. UAS核心产生一个2xx应答。这个应答建立一个对话
2. 响应INVITE请求的2xx应答包含Allow头域和Supported头域，并且可能包含Accept头域。包含这些头域的目的是为了让UAC不需要再次请求就能够知道UAS的特性以及UAS的扩展支持。
3. 当应答构建好了以后，它会交给INVITE的服务端事务层进行发送
4. INVITE的服务端事务将会由于收到这个终结应答并且交给通讯层进行发送而销毁。因此，有必要在没有收到ACK的时候，每隔一定的时间就直接交给通讯层进行发送

## 更改已存在的会话

1. 一个成功的INVITE请求（13节）既会创建一个基于两个用户之间的对话，也会基于请求/应答模式（offer－answer）创建一个会话
2. 修改实际的会话（session）可以包括修改地址或者端口、增加媒体流、删除媒体流等等
3. 通过发起新的INVITE请求来完成的，并且这个新的INVITE请求是基于建立会话所相同的对话的
4. 在一个现存对话中发出INVITE请求就是re-INVITE.
   1. 单个的re-INVITE请求可以同时更改对话和会话的参数
   2. 呼叫方或者被叫方都可以更改现存的会话
5. 不建议自动产生re-INVITE或者BYE请求(应当等待一个随机的时间间隔)
   1. 可能会导致网络上的阻塞

### UAC行为

1. offer-answer模式在re-INVITE中也一样采用
2. 假设UAS希望增进一个媒体流，那么UAC将会创建一个新的offer包含这个媒体流，并且发送INVITE请求给他的对方
   1. 传送的是会话的全描述
   2. re-INVITE请求而不包含会话描述则在200中描述offer
3. re-INVITE请求中的To,From,Call-ID,Cseq,Request-URI头域应当和正常的在对话中的请求构造方法一样
4. INVITE可以分支（分岔成为多份INVITE）,re-INVITE是不会分支的
   1. 只会由一个单个的终结应答
   2. re-INVITE不会分岔的原因是因为Request-URI标志的是建立对话的UA的目标地址，而不是用户的address-of-record地址
5. 相同的对话中，UAC不能在上一个INVITE请求完成前（无论是那一方发起的INVITE）再次发起一个新的INVITE
   1.  如果有正在处理的INVITE客户事务，TU必须等待这个事务终结或者完成，才能初始化一个新的INVITE
   2.  如果有正在处理的INVITE服务事务，TU必须等待这个事务确认或者终结，才能开始处理一个新的INVITE
   3. UA可以在INVITE事务正在处理的同时，处理一个普通的事务。也可以在一个普通事务正在处理的同时来初始化一个INVITE事务。
6. 如果UA接收到一个针对re-INVITE的非2xx终结应答，则会话参数不能改变，应当就像没有收到过这个re-INVITE请求一样
   1. 如果非2xx终结应答是一个481、408或者完全没有re-INVITE请求的应答，UAC会终止这个对话
7. UAC收到一个re-INVITE的491应答
   1. 当启动一个值为T的时钟
      1. 如果UAC是这个dialog ID的Call-ID的拥有者。（也就是说是UAC产生的Call-ID）,那么T取值为一个2.1到4秒的随机数，单位是10毫秒。
      2. 如果UAC并非是dialog ID的Call-ID的拥有者，T应当取值是0到2秒的随机数，单位是10毫秒
   2. 当这个时钟到了，如果UAC还希望再次尝试更改会话参数，UAC应当再次尝试re-INVITE请求一次(如果这个呼叫已经被BYE所挂掉了，那么re-INVITE请求就没有再发的必要)
8. 发送re-INVITE请求的规则，以及针对re-INVITE请求产生的2xx应答而产生的ACK请求的发送规则，等同于初始的INVITE请求

### UAS行为

1. 500响应
   1. UAS在发送第一个INVITE的终结应答之前，收到第二个INVITE请求，并且这个请求的Cseq序列号大于第一个INVITE请求，那么就应当给第二个INVITE请求返回一个500，并且必须包含一个Retry-After头域，这个头域中应当包含一个0－10秒的随机数
2. 491响应
   1. 如果UAS正在处理一个INVITE请求的时候又收到了一个在同一个对话上的INVITE请求
3. UA接收到一个对现存的对话的re-INVITE请求，检查有关会话描述(session description)的版本标志（version identifiers）,或者，如果没有版本标志，那么就需要检查会话描述的正文看看有没有变化
   1. 如果会话描述改变了，UAS必须由此调整会话参数，在调整参数的时候可能会要求用户确认
4. 会话描述的版本可以用来提供给会议的新近加入者，增加或者删除媒体，或者由单点会议更改成为多方会议
5. 488响应
   1. 如果新的会话描述是不能被UA接受的，UAS可以用返回一个488，这个响应应当包含一个Warning头域
6. 180响应
   1. UAS不可以产生180给re-INVITE

## 结束一个会话

1. 会话的状态和对话的状态是密切相关的
2. 来自不同的UAS的每个1XX，2XX响应都会创建一个对话，如果该响应完成了(offer/show)交换，则还会创建一个对话
3. 每一个会话都和单个对话相关
4. 如果初始化的INVITE产生了非2xx的终结应答，它也终结了由本次请求创建的任何会话（如果有的话），并且终结了所有的本次请求创建的对话（如果有的话）
5. 当在对话中接收到了一个BYE,任何与该对话相关的会话都应当终止
6. UA禁止在对话外发送BYE请求
7. 在一个建立好的对话中，被叫方的UA不能在接收到对应2xx应答的ACK请求前发送BYE请求，或者不能在服务器事务超时前发送BYE请求
8. 如果UAC希望cancel 这个INVITE请求，那么就会发出CANCEL请求，如果接收到了非2xx的终结应答，就意味着CANCEL掉了，但是如果接收到的还是2xx应答，就说明没有CANCEL掉，没有CANCEL掉呢，就可以选择继续建立会话，或者说发送一个BYE来终结会话

### 使用BYE请求终止一个会话

#### UAC行为

1. BYE请求就像其他在对话内的请求一样的构造
2. BYE请求创建好了之后，UAC核心处理部分创建一个新的非-INVITE客户端事务，并且用它来处理BYE请求
3. UAC必须认为当BYE请求一发送到客户端事务，会话就结束了
4. 如果BYE请求的应答是481、408、或根本没有应答，UAC必须认为会话和对话都已经结束

#### UAS行为

1. UAS首先按照通用的UAS接收到请求的处理步骤进行BYE请求的处理
2. 首先检查它是否和现存的对话匹配
   1. 不匹配产生481传给服务器事务，因此，UAC发送没有带tag标志的BYE请求会被拒绝
   2. 匹配，遵循对话中的处理步骤，一旦处理完成，UAS应当终止这个会话
   3. 唯一一个可以选择不终止的情况是多方会话
3. 不管是否终止会话中的参与方，UAS核心处理都必须给BYE产生2xx的应答，并且必须由服务器的通讯层进行传输。
4. UAS必须依旧响应在这个对话中接收到的未决的请求。我们建议用487（请求终止）来给这些未决的请求以应答。

## proxy行为

### 概述

1. SIP代理是将SIP请求路由到用户代理服务器和SIP响应到用户代理客户端的元素。
2. 一个请求可能通过多个proxy到达UAS，每一个都会作出路由决定，在发送给下一个节点前对请求做一点修改
3. 应答会通过和请求相同的proxy路径，只是顺序是逆序的
4. proxy是一个SIP逻辑上的概念，当接收到一个请求，在做代理服务器之前，首先应该有一个部件来决定是否自身需要响应这个请求
   1. 在作为代理服务器处理请求之前，首先判定请求可能是非法的或者请求需要一个信任状
   2. 当直接应答请求的时候，这个元素（proxy）将作为UAS角色，并且必须遵循UAS行为规范。
5. proxy对于每一个新的请求来说，既可以作为有状态的也可以作为无状态的模式来处理
   1. 作为无状态的处理模式的时候
      1. proxy就是简单的转发；转发每一个请求下行到一个由请求所决定的目的地。并且简单转发从上行流取得的应答
      2. 一个无状态的proxy在处理完一个消息之后就会丢弃这个消息的相关资料，有状态的proxy会保留这些信息（尤其是事务信息）
   2. 作为有状态的proxy
      1. 可以选择”分支”一个请求，路由它到多个地点。任何被路由到多个地点的请求都必须当作有状态的处理
      2. 有状态的proxy可以在处理请求中的任何时候转换成为无状态的，只要它不作任何可能导致不能无状态的操作(当做这样的转换的时候，所有的状态就只是简单的废弃掉)
6. proxy可以用有状态的通讯协议（比如TCP）来转发请求，而不用自身成为事务有状态的
7. proxy不应当发起一个CANCEL请求

### 有状态的proxy

1. 必须是一个纯粹的SIP事务处理引擎
2. 这个事务与一个或者多个客户端事务相关，这些客户端事务是由高层proxy处理元素产生的
3. 高层proxy处理元素(Proxy Higher Layer)就是proxy处理核心
4. 个输入的请求是通过一个服务端事务来处理的。请求由服务端事务交给proxy处理核心进行处理
5. proxy处理核心检查请求应当路由到哪里，选择一个或者多个下一个节点(每一个发往下一个节点的外发请求都由客户端事务进行处理)
6. proxy处理核心从客户端事务中得到请求的应答并且把他们的应答交给服务端事务进行发送
7. 有状态的proxy为每一个接收到的新的请求创建一个服务端事务,任何请求的重复都是由这个服务端事务来处理
8. 对于所有的新请求(包括未知方法的请求)，proxy处理请求必须：
   1. 验证请求
   2. 预处理路由信息
   3. 决定请求的目的
   4. 转发请求到每一个目的地
   5. 处理所有的应答

### 验证请求

1. 在proxy转发之前，必须检查消息的合法性
   1. 合法的语法
      1. 请求要能够被服务端事务处理，那么请求就必须是语法无误的
      2. 请求中的任何与检查相关的部分或者与请求转发节相关的部分都必须语法严格无误
      3. 其他部分的严格与否，在检查中都被忽略
      4. 在转发消息过程中保持不变
   2. URI scheme
      1. 如果Request-URI包含一个proxy所不能理解的URI形式，那么proxy应当通过返回一个416来拒绝这个请求
   3. 最大转发次数
      1. 如果请求没有包含Max-Forwards头域，那么这个检查将被忽略
      2. 如果请求包含了一个Max-Forwards头域，并且这个头域大于0，那么这个检查就跳过
      3. 如果请求包含一个Max-Forwards头域，并且这个头域为0，那么这个proxy不能转发这个请求
      4. 如果请求是OPTIONS请求，那么proxy可以作为最终响应者来响应这个请求
      5. 否则proxy应当返回一个483
   4.  (可选)循环检测（loop detection）
      1. proxy可以检查看看转发是否可能导致循环
      2. 如果请求包含一个Via头域，并且这个头域值，和proxy早先保留的请求的头域值相同，那么这个请求就是以前经过过本proxy
      3. 要检测请求是否循环处理，proxy可以用branch参数
      4. 增加一个Via头域和接收到的Via头域做比较。如果参数相等，那么请求就循环了
      5. 如果检测到了循环，那么proxy应当返回一个482
   5.  proxy-require
      1. proxy就可以根据Proxy-Require判定自己是否能够支持这些特性
   6.  proxy-authorization
2. 以上任何一步失败了proxy都必须作为UAS应答一个错误码
3. 意proxy并不要求检查合并的请求，并且不能把合并的请求当作一个错误的情况

### 路由信息预处理

1. proxy必须检查请求中的Request-URI部分
2. 如果Request-URI包含了一个本proxy早先放在Record-Route头域中的值proxy必须用Route头域中的最后一个值来替换Request-URI，并且从Route头域中删去这个值。proxy必须接着按照个修改后的请求进行处理

### 确定请求目的

1. proxy计算请求的目的（或者多个目的地）。目的地集合可以由请求的内容决定或者由绝对位置服务提供
2. 目的地集合中的每一个目的地都由URI来表达
3. Request-URI
   1. 如果请求中的Request-URI包含了maddr参数，必须把Request-URI放在目标集合中，并且是作为唯一一个目标URI
   2. 如果Request-URI的区域并非本proxy负责的区域，那么Request-URI必须放在目标集合中，并且作为唯一一个目标URI
      1. 例如：一个防火墙proxy处理外发的请求（就像HTTPproxy处理外发的请求）
4. 如果请求的目标集合没有像上边讲述的这样预先设定，那么这就意味着proxy是负责Request-URI所指明的区域的。此时，proxy可以用任何机制来决定往哪里发送这个请求
   1. 这些机制都可以归结成为访问一个绝对位置服务的形式
      1. 从SIP注册服务器创建的位置服务器获得信息
      2. 读取数据库
      3. 查阅服务器
      4. 利用其他协议
      5. 简单的替代Request-URI
5. 如果Request-URI没有提供足够的信息来让proxy能够产生目的地集合，它应当返回一个485。这个应答应当包含一个Contact头域包含一些应当尝试的新位置
6. 任何与这个请求有关的，或者与proxy当前环境有关的信息都可以用来构造目的地集合
7. 根据以上机制，可以有一个可能的目的地列表，他们的URI被增加到目的地集合
   1. 每一个目的地只能在目的地列表中出现一次
8. 如果原请求的Reuqest-URI指明的区域并非本proxy所负责的区域，那么本proxy不能增加任何额外的目的地到目的地集合
9. 如果proxy负责Request-URI所指明的区域
   1. 这个proxy只可以在转发的时候改变请求的Request-URI，它也不会在3xx或者416应答的时候查生递归。
   2. proxy可以在请求转发的时候增加目的地(用任何可以获得的信息来决定新的目的地)
10. 如果Request-URI是这个proxy所负责的，但是在本proxy中找不到，那么proxy必须返回404
11. 如果目的集合经过上边的处理依旧是空的，那么proxy必须返回一个错误应答，这个错误应答应当是408

### 请求转发

1. 当目的地集合不是空的时候，proxy可以开始转发这个请求
2. 有状态的proxy可以按照任意的顺序处理这个目的地集合
   1. 可以顺序处理多个目的地，上一个完成前下一个不能开始
   2. 也可以采用并行的处理多个目的地
   3. 也可以通过分组的形式，每组之间是串行的，组内是并行的
3. 通常的处理顺序机制是使用一个Contact头域的qvalue参数来处理
   1. 目的地从最高的qvalue开始处理到最低的qvalue。相同qvalue的目的地可以并行处理
4. 有状态的proxy必须包含针对目的地集合的一个接收到应答和转发出去的原始请求进行匹配的机制
   1. 这个机制是一个由proxy层在转发第一个请求前创建的”response context”(应答上下文)来保障的。
5. 对于每一个目的地，proxy转发请求都遵循下列步骤：
   1. 拷贝一个接收到的请求
      1. 拷贝必须包含接收到的请求的全部头域，拷贝应当保留接收到的请求的头域的顺序
      2. proxy不能增加、修改、删除消息体
   2. 更新Request-URI
      1. **proxy的本质步骤**，proxy通过这个机制来把请求转发到目的地
      2. 在拷贝好的请求中的Request-URI必须用目的地的URI进行替换
      3. 如果这个目的URI包含任何在Request-URI中所不能允许的参数，那么这些参数必须被删去
   3. 更新Max-Forwards头域
      1. 如果拷贝的头域包含一个Max-Forwards，proxy必须把这个域值减一
      2. 如果拷贝的头域没有包含一个Max-Forwards头域，proxy必须自己增加一个头域，缺省值是70
   4. 可选增加一个Record-Route头域
      1. （假设proxy接收到的这个请求会创建一个对话的情况下），如果希望保留这个请求创建的对话中，后续的请求依旧是要经过本proxy，那么本proxy必须增加一个Record-Route头域，并且增加的这个头域值应当是在其他现存的Record-Route头域之前
      2. 如果这个请求已经是一个对话的一部分，proxy如果希望以后这个对话的请求依旧经过本proxy，那么proxy应当增加一个Record-Route头域值
         1. 如果proxy不增加一个Record-Route头域在请求的包头，后续的请求也会经过本proxy。但是，如果当终端中断并且重新构造这个对话的时候，本proxy就会从对话所经过的节点中删去。
      3. 一个proxy可以在任何请求中增加这个Record-Route头域值
      4. 在请求路径上的每一个proxy都是独立的决定是否增加一个Record-Route头域值
      5. 在Record-Route头域中放置的URI必须是SIP或者SIPS URI且必须包含lr参数
         1. 这个URI可以和请求将被转发的地方不同
         2. 这个URI不应当包含通讯参数(除非该proxy确认在后续请求将会经过的下行节点中，都支持这个通讯参数)
      6. 本proxy提供的这个URI可能会让其他元素（其他proxy）作出路由决定
         1. 本proxy，通常，并不知道其他节点的处理能力，所以，它必须严格律己，让自己遵循规范
      7. 在Record-Route中的URI必须指向插入它的元素（或者替代元素)，这样后续的请求才能顺利到达同一个SIP元素
      8. 如果请求不是基于TLS接受的，那么proxy必须增加一个Record-Route头域
      9. 在安全范畴内的proxy必须在对话中保持这个安全范畴
      10. 当Record-Route头域的URI在应答中又重新到达的时候，如果这个URI值需要重写，这个URI必须是能够唯一确定的URI(请求可能会经过这个proxy好几次，造成一个或者多个Record-Route头域值的增加)
      11. proxy可以在Record-Route头域中增加一些参数，这些参数在某些请求的应答中会被反射（echo）回来
      12. 如果proxy想在任何类型的对话中都保持在请求的路径上(跨越防火墙)，需要给每一个接收到的请求中，都增加Record-Route头域，即使是它所不能理解的方法
      13. 在Record-Route头域中增加的URI只是在当这个请求创建对话的时候有效
      14. 当proxy需要查看所有对话中的消息的时候，我们就需要Record-routeing
          1. 会降低处理性能和影响扩展性，因此proxy应当只在特定情况下使用record-route
   5. 可选增加附加的头域
      1. proxy可能增加其他适当的头域
   6.  路由信息后处理
      1. proxy可以有一个本地的策略，这个策略要求请求在传递到目的地之前，必须经历一个proxy集合
         1. 这样的proxy必须能够确保所有的类似的proxy都是松路由（loose routers）的(只有当这些proxy都是在相同的区域管理的时候，我们才可能知道这些proxy是否都是松路由的)
         2. 这个proxy的集合是通过一组URI的集合表示（每一个都包含一个lr参数）
         3. 这个集合必须被放置到Route头域中，并且放置在其他头域值之前。如果Route头域不存在，必须增加一个Route头域，包含这组URI的列表。
      2. 如果代理具有强制请求访问一个特定代理的本地策略，则将Route值推送到Route头字段的替代方法是绕过下面第10项的转发逻辑，而只是将请求发送到该地址，端口，以及该特定代理的传输
         1. 如果请求具有Route头字段，则除非已知下一跳代理是松散路由器，否则不得使用此备选方案
      3. 如果请求的拷贝中包含了Route头域，这个proxy必须检查这个Route头域的第一个值的URI，如果这个URI并没有包含lr参数，那么proxy必须根据下列步骤修改这个请求：
         1.  proxy必须把Request-URI放在Route头域中的最后一个值
            1. 为了让Request-URI的信息能够通过严格路由的proxy
         2. proxy必须把第一个Route头域的值放在Request-URI中，并且从Route头域中删去
            1. 为了能够让严格路由元素能够接收到这个请求
   7.  决定下一个节点地址、端口、通讯协议
      1. proxy可以有自己的策略来决定发送请求到特定的IP地址，端口和transport，可以和Route的值或者Request-URI的值无关
         1. 当本proxy不能确定对应ip,端口，transport的服务器是一个松路由（loose router）的时候，这样的策略就不能使用了
         2. 除了Route头域应当像上边讲的这样使用，我们并不推荐这样的发送请求的机制
      2. 在没有这样一个替代机制的时候，proxy会依据一些步骤和程序最终生成一个序列集合(地址，port，transport)
         1. proxy必须尝试序列集合中的第一组元素，并且依次尝试序列集合中的每一组元素，直到成功为止
         2. 对于每一组的尝试，proxy必须按照这组的通讯要求，对消息进行适当的格式化，并且用一个新的客户端事务，进行请求的发送。
         3. 由于每一组的发送都是使用心得客户端事务，这就体现了一个新的分支。因而，第8步插入的Via头域中的分支参数必须每组发送的都不一样。
         4. 如果客户端事务报告发送请求失败，或者它自身的状态机超时，proxy就应当继续处理序列集合中的下一组元素。当遍历完序列集合之后，请求就不能发送到目的地集合
   8. 增加一个Via头域值
      1. proxy必须在请求的拷贝中增加一个Via头域值，并且在其他Via头域值之前增加。
         1. 这意味着proxy需要计算自己的分支参数，并且应当是全局唯一的分支，并且包含必要的magic cookie。
         2. 如果请求循环经过本proxy的时候（也就是数次经过同一个proxy），每次的分支参数都不同
      2. 在proxy构造分支参数的值上，有一个附加的约束，用来进行循环的检测
         1. 一个要检测循环的proxy应当创建一个由两部分组成的分支参数
         2. 从螺旋中判定是否存在循环
         3. 循环检测是通过这样的方法
            1. 当请求返回给一个proxy，与处理请求相关的字段并未改变，那么这个就是循环了
            2. 如果请求从别处重新路由回来，而且这些字段改变了，那么这就是一个螺旋
            3. 通过计算hash值
      3. 如果proxy希望检测循环，那么”branch”参数必须用包含可能影响处理请求的全部信息构成，包括输入的Request-URI和其他可能会影响proxy处理路由的字段
      4. 在branch参数的计算上，请求的方法不能计算进去。但是作为特例，CANCEL和ACK请求（给非2xx应答的）必须和他们对应的请求有相同的branch值
   9. 如果需要，增加一个Content-Length头域
      1. 如果请求会通过一个基于流的通讯协议发送到下一个节点，并且发送的请求拷贝中没有包含一个Content-Length头域，那么proxy必须增加一个正确的请求包体大小在这个头域
   10.  转发这个新的请求
       1. 一个有状态的proxy必须为这个请求创建一个新的客户端事务，并且指示事务层用第7步指定的地址，端口和协议进行发送
   11. 设置定时器C
       1. 为了能够处理INVITE请求没有产生终结应答的情况，TU使用一个定时器（称作定时器C）
       2. 当INVITE请求被转发的时候，必须为客户端事务设定一个定时器C。
       3. 这个定时器C必须大于3分钟

### 应答的处理

1. 当proxy收到一个应答的时候，它首先尝试定位一个与这个应答匹配的客户端事务
   1. 如果没有匹配，proxy必须作为无状态的proxy来处理这个应答
   2. 如果与应答匹配的客户端事务找到了，那么这个应答将转给这个客户端事务进行处理
      1. 保证了”晚到”的给INVITE请求的2xx应答能够正确的转发。
2. 客户端事务把应答交给proxy层，将会执行下列步骤：
   1.  寻找适当的应答上下文。
      1. proxy通过16.6节定义的方法来在寻找转发原始请求前创建的”应答上下文” 。在这个上下文中进行后续的处理步骤。
   2. 用临时应答来更新定时器C
      1. 对于INVITE事务，如果应答是一个返回码是101到199的临时应答，proxy必须给这个客户端事务重新设置定时器C
      2. 这个定时器可以设置成为其他的值，和原始值不一样，但是这个数字必须大于3分钟
   3. 从最上边移除Via
      1. proxy从应答中移去Via头域中最上的值。
      2. 如果在这个应答中没有这个Via头域值，那么应答的含义就是说这个应答不应当被这个proxy转发
   4. 在应答上下文中增加应答
      1. 收到的终结应答都会保存在应答的上下文中，直到收到一个由服务端事务产生的针对这个上下文的终结应答为止。这个应答是从那个服务端事务中收到最佳终结应答的一个候选
      2. 如果proxy决定尝试调用3xx应答返回的联系地址，并且把他们添加到目的地集合，它必须在把这个应答添加到应答上下文之前把联系地址从应答中移除
      3. 从应答中删去联系地址的目的是为了防止下一个节点尝试本proxy已经尝试的地址
      4. 如果proxy在转发请求的时候自己调换了请求的SIP或者SIPS为一个什么其他的东西），proxy应当增加一个新的URI到目的地集合。这个URI应当是刚才尝试的非SIP URI的SIP URI版本
   5. 检查这个应答是否需要立刻发送
      1. 当终结应答到达服务端事务的时候，下列应答包必须立刻转发：
         1. 任何非100（trying）的临时应答
         2.  任何2xx应答。
      2. 如果收到一个6xx应答，那么就不立刻进行转发，如果是有状态的proxy，那么还需要cancel所有的依赖于这个事务的客户端，并且不能在上下文中创建新的分支。
      3. 在服务端事务上发送了终结应答之后，下列的应答应当立刻被发送：
         1. 任何给INVITE请求的2xx应答。
      4. 一个有状态的proxy必须不能立刻转发其他的应答
      5. 任何将被立刻发送的应答都必须遵照”7、 需要合并认证头域值。”和”8、可选的重写Record-Route头域值”来处理。
   6. 如果需要，从应答上下文中选择最好的终结应答
      1. 对于一个有状态的proxy来说，如果根据上边的步骤，没有任何终结应答被立刻发送，并且在客户端事务中的所有的客户端服务都已经终结，那么这个proxy必须发送一个终结应答到一个应答上下文的服务端事务层。
      2. 如果在上下文中没有一个终结应答，那么proxy就必须返回一个408
      3. 如果应答上下文中有终结应答，那么proxy就必须从这个应答上下文中取得应答来发送
         1. 如果应答上下文中有6xx应答，那么就必须选择这个6xx应答
         2. 如果没有6xx应答，那么proxy应当选择最小的应答，proxy可以选择对应最小应答系列中的任意一个应答
         3. 。proxy应当给那些提供对影响请求的应答更多的机会
3. 如果在与这个应答上下文相关的每一个客户端事务都结束的以后，还是没有终结应答转发，那么proxy必须选择从已经收到的应答中，选择转发”best”应答回去
4. 每一个被转发的应答上执行的步骤
   1.  需要合并认证头域值
      1. 如果选择的应答是401（Unauthorized）或者407（Proxy Authentication Required），proxy就必须从本应答上下文中的所有其他401（Unauthorized）和407应答中搜集WWWAuthenticate和Proxy-Authenticate 头域值。并且把这些信息增加到这个应答中
      2. 由于这个请求的一个或者多个目的地可能是需要请求身份验证的，所以这个搜集步骤就是必须的
   2. 可选的重写Record-Route头域值
      1. 如果最终发送的应答中包含Record-Route头域值，并且是这个proxy所原创提供的值，那么在发送这个应答前，proxy可能需要重写这个值
         1. 让proxy能够给下一个上行节点或者下行节点提供非本机的一个URI地址
      2. 如果proxy是通过TLS收到请求的，并且通过非TLS转发出去，proxy必须重写在Record-Route头域中的URI，重写成SIPS URI
      3. 如果proxy通过非TLS接收到请求，转发是通过TLS转发的，那么proxy必须重写Record-Route请求头域的URI为一个SIP URI。
      4. URI不应当包含通讯参数除非proxy知道下一个上行（同下行队列对应的）节点，对于后续的请求都支持相关的通讯参数
      5. 如果proxy打算修改应答中的Record-Route头域，要做的一件事情就是定位插入的Record-Route头域值
   3. 转发应答
      1. proxy可以对这个应答做其他的附加处理
      2. 但是这个proxy不能增加、修改、删除消息体，并且除非另有指示，除了Via头域值（在16.7节3步）之外，proxy不能删除任何头域值。
      3. proxy必须维持应答上下文直到所有相关事务都已经终结，甚至在发送完成终结应答后还需要维持
   4. 产生合适的CANCEL请求。
      1. 如果转发的应答是一个终结应答，proxy必须给依赖于这个应答上下文的所有客户端事务，产生CANCEL请求
      2. 在收到6xx应答的时候，proxy同样应当为所有等待在这个应答上下文的客户端事务产生CANCEL请求

### 处理定时器C

1. 如果定时器C被触发了，proxy必须用另外一个数值重新设定定时器，要么终结客户端事务
2. 如果客户端事务已经收到了临时应答，那么proxy必须产生一个与之匹配的CANCEL请求
3. 如果客户端事务还没有收到临时应答，那么proxy必须就像收到一个408
4. 允许proxy重设定定时器就意味着允许proxy基于当前条件（比如服务器利用率等等）动态的扩展事务的生命周期

### 处理通讯层的错误

1. 如果在转发请求的时候，通讯层报告了一个错误，那么proxy必须就像收到了一个503（Service Unavailable）应答一样的处理。
2. 如果proxy在转发应答的时候接收到错误，那么他就丢弃应答
3. proxy不能由于通讯的原因而cancel任何和这个应答上下文相关的客户端事务
   1. 如果proxycancel了这些客户端事务，那么一个恶意的或者出错的客户端可以用一个Via头域导致所有的事务都失败

### CANCEL处理

1. 一个有状态的proxy可以给他自己产生的其他请求在任何时候都产生CANCEL请求
2. 在接收到一个匹配的CANCEL请求的时候，proxy必须取消任何与应答上下文相关的客户端事务。
3. 当INVITE请求有一个Expires头域并且这个头域值已经超时的情况下，一个有状态的proxy可以对这个处于pending的INVITE客户端事务发出CANCEL请求
   1. 通常来说，这是不必要的，因为相关的终端会发出结束事务的信号。
4. 当有状态的proxy在它自己的服务端事务上处理CANCEL请求的时候，并没有新的应答上下文会创建
   1. 相反，proxy层寻找与这个CANCEL对应请求的现存的应答上下文
      1. 如果找到了对应的应答上下文，那么这个节点应当立刻返回一个200
      2. 如果一个应答上下文没有找到，这个节点就无法CANCEL这个请求，它就必须像无状态proxy一样转发这个CANCEL请求

### 无状态proxy

1. 作为无状态的时候，proxy就是一个简单的消息转发者
2. 一个无状态的proxy并没有事务的概念，或者用于描述有状态proxy行为的应答上下文
3. 无状态的proxy处理消息，无论是请求还是应答，都是直接从通讯层处理
4. 无状态proxy自己也不重发这些消息。他们只是转发他们收到的任何重发的消息
5. 当无状态的处理一个请求的时候，这个节点并不产生它自己的100（Trying）或者其他临时应答
6. 无状态proxy的几点不同
   1.  无状态的proxy必须从目的地集合中，选择一个并且只能选择一个目的地
      1. 这个选择必须是根据消息的头域并且是和服务器时间无关的
      2. CANCEL和非路由的ACK请求必须和他们相关的INVITE请求有相同的转发目的地
   2. 无状态proxy的branchID必须要求在时间上和空间上都是唯一的
      1. 无状态的proxy不能简单的使用一个随机数产生器来计算branchID的第一个部分，因为请求的重发需要相同的值且无状态的proxy不能区分重发的请求和原始请求
      2. 对于无状态的proxy来说，branch参数必须作为一个重发无关的消息处理参数存在
      3. 推荐的保证branchID唯一性的方法：
         1. proxy检查在接收到请求的最上Via头域值的branchID。如果它是由magic cookie打头的，那么branchID的第一个部分就是当作接收到的branchID的hash值
         2. 否则branchID的第一个部分就当作是Via头域的最上值、To头域的tag、From头域的tag，Call-ID头域，Cseq序列号（除了方法部分），接收到的请求的Request-URI的一个hash值
   3. 所有其他的消息转换必须保证转发重发的请求的时候能够转发到相同的节点
      1. 如果proxy在Record-Route头域中增加了值，或者在Route头域中增加了值，proxy必须在转发重发的请求的时候增加相同的值
      2. 转发必须是基于时间无关的配置或者请求重发无关的属性
   4. 一个无状态proxy决定转发的地点和有状态的proxy一样，但是请求是直接交给通讯层发送的，而不是交给客户端事务
7. 无状态的proxy必须不能对CANCEL做特别的处理

### Proxy Route处理的总结

1. 在没有本地策略的情况下，proxy对于包含Route头域的请求处理可以归结于如下的步骤：
   1. proxy会检查Request-URI
      1. 如果它指向的是本proxy所负责的区域，那么proxy会用位置服务的结果来替换这个URI
      2. 否则，proxy不改变这个URI。
   2. proxy会检查Route头域的最上URI
      1. 如果这个URI指向这个proxy，这个proxy从Route头域中移除（这个路由节点已经到达）
   3. proxy会转发请求到最上的Route头域值所标志的URI，或者Request-URI(如果没有Route头域)。
2. 如果在请求的路径中，没有严格路由节点，Request-URI会始终标志着请求的目的地

#### 例子



## 事务

1. SIP是一个基于事务处理的协议：部件之间的交互是通过一系列无关的消息交换所完成的
2. 一个SIP 事务由一个单个请求和这个请求的所有应答组成，这些应答包括了零个或者多个临时应答以及一个或者多个终结应答
3. 在事务中，当请求是一个INVITE（叫做INVITE事务），当终结应答不是一个2xx应答的时候，事务还包括一个ACK。如果应答是一个2xx应答，那么ACK并不认为是事务的一部分
   1. 分开的原因：delivering all 200 (OK) responses to an INVITE to the UAC.是很重要的
      1. UAS独自负责这些应答的重新传送
      2. UAC独自负责挨个ACK确认
      3. 所以在自己的事务中进行重传会比较有效
4. 事务分为客户端和服务端两方
   1. 客户端事务发出请求，并且服务端事务送回应答
   2. 客户端和服务端事务都是逻辑上的概念，他们可以被无数部件所包含
   3. 在UA中和有状态的proxy服务器中存在
5. 无状态的proxy并没有客户端或者服务端的事务
6. 事务是一边基于UA或者有状态的proxy，另外一边也基于UA或者有状态的proxy
7. 2xx应答和它的ACK请求通过特定的方式来接收和处理
   1. 这个应答只会被UAS重发，并且它的ACK只由UAC产生

### 客户端事务

1. 客户端事务是通过维持一个状态机来提供服务的
2. TU和客户端事务通过一个简单的接口进行通讯
   1. 当TU希望初始化一个新的事务，它创建一个客户端事务并且通过设置ip地址，端口和transport来把一个SIP请求交给它传送
   2. 然后客户端事务开始执行它自己的状态机。合乎规格的应答会从客户端事务传送给TU
3. 总共有两种类型的客户端事务状态机：(根据TU传递的请求的方法不同来区分)
   1. 一个用于处理INVITE请求
      1. 这种状态机对应的是一个INVITE客户事务
   2. 另外一个是用来处理其他所有的非INVITE请求的
      1. 它对应的是非INVITE客户事务
4. 对于ACK来说，是不存在客户事务的。如果TU希望送一个ACK请求，它直接交给通讯层进行通讯处理。
5. INVITE事务和其他事务是不同的，因为它的时间周期很长
   1. 通常，对于INVITE请求的应答来说，都需要人的参与
   2. 其他非INVITE请求事务是双方的握手，TU能够立刻对非INVITE请求作出应答

#### INVITE客户事务

##### INVITE事务概述

1. INVITE请求包含了一个三方的握手
   1. 客户端事务发送一个INVITE，服务端事务回送一个应答，客户端事务发送一个ACK
2. 对于非可靠传输（比如UDP）
   1. 客户端事务每隔T1重发请求，每次重发后间隔时间加倍。
   2. T1是一个估计的循环时间，缺省设置成为500ms
      1. 几乎所有的事务定时器都以T1为单位，并且调整T1的值也就调整了那些定时器的值
3. 请求不会在可靠的通讯协议上重新发送
   1. 在接收到1xx应答以后，重发机制完全停止，并且客户端等待更进一步的应答。
4. 对于非可靠的传输协议，应答会间隔时间来重发，对于可靠的传输协议，它只发送1次
   1. 对于客户端事务所接收的每一个终结应答，客户端事务都发送一个ACK，用于终止应答的重发送。

##### 正式的描述

1. 初始状态，”calling”，必须保证TU是用INVITE请求来初始化一个新的客户端事务，客户端事务必须把请求发送到通讯层来进行发送
   1. 如果使用的是非可靠传输的通讯层，客户端事务必须启动一个定时器A并且由缺省值T1组成
   2. 如果是一个可靠的通讯协议，那么客户端事务不应当启动定时器A（定时器A控制请求的重发送）
   3. 对于任何通讯协议来说，客户端事务必须启动一个定时器B并且有着64×T1秒的缺省值（定时器B控制事务的超时）
   4. 当定时器A触发了，客户端事务必须重发这个请求，把请求交给通讯层进行发送，并且重新设置定时器为2*T1。在传输层中重传的定义是指把刚才通过传输层发送的消息，再次交给传输层重新发送一次。
      1. 当定时器A在2×T1后触发了，请求必须再次重传（如果客户端事务依旧还是在这个状态的话）
      2. 这个处理必须持续下去，这样请求才能每重发一次以后定时器延时1倍。重发机制只有当客户端事务在”calling”状态的时候才能进行。
   5. 当定时器B触发的时候，如果客户端事务是依旧在”calling”状态，那么客户端事务应当通知TU发生了超时
2. proceeding
   1. 如果客户端事务在”calling”状态接收到一个临时应答，那么就把状态切换到”proceeding”状态
   2. 客户端事务不应当再次重新发送请求
   3. 在”proceeding”状态的任何临时应答都必须传送给TU
3. Completed
   1. 当在”calling”或者”proceeding”状态的时候，如果接收到一个应答码是300-699的应答，那么就必须把状态切换到”Completed”
   2. 客户端事务必须把收到的应答转给TU，并且客户端事务必须产生ACK请求并且把ACK交给传输层进行传送
   3. ACK必须和原始请求发送到相同的地址，端口和用同样的transport
   4. 当客户端事务进入”Completed”状态的时候，应当开始一个定时器D
      1. 缺省值是在非可靠通讯上是至少32秒，在可靠通讯上是0秒
      2. 定时器D反应了服务端事务在非可靠传输的情况下，在”completed”状态维持的时间
      3. 这个是和INVITE请求服务端事务定时器H相同的
   5. 在”completed”状态下，受到的任何终结应答的重传都应当产生一个ACK应答到通讯层来重新发送，但是新近收到的应答却不能传送给TU
4. terminate
   1. 在客户端事务状态是”Completed”的时候，定时器D触发，那么客户端事务必须转到终结状态
   2. 当客户端状态是”calling”或者”proceeding”状态的时候，接收到一个2xx应答必须导致客户端事务进入”terminated”状态。并且应答必须交给TU处理
      1. 处理这个应答的方法依赖于TU是否是一个proxy核心还是是UAC核心
         1. UAC核心会给应答产生ACK
         2. proxy核心会转发一个200(OK)应答到上行队列
         3. 这个在proxy和UAC之间，对200(OK)的不同的处理是导致对应答的处理不在事务层进行的原因
   3. 当客户端事务进入”terminate”状态以后，客户端事务必须立刻销毁

##### 构造ACK请求

1. 在客户端事务中构造ACK请求的方法
2. 在客户端事务中构造的ACK请求必须包括与原始请求相同的Call-ID, From, Request-URI头域值
3. 在ACK请求中的To头域必须和被确认的应答的To头域值相同，因此通常和原始请求有所不同，不同点在增加了附加的tag参数
4. ACK必须包含一个单个的Via头域，并且必须和原始请求的最上边一个Via头域值相等
5. ACK的Cseq头域必须包含和原始请求的Cseq的序列号相同，但是方法参数应当是”ACK”
6. 如果INVITE请求的应答是有Route头域的，这些Route头域必须也在ACK中
   1. 确保ACK能够正确路由通过下行队列的无状态的proxy
7. 不建议在给非2xx应答的ACK请求中放置包体
   1. 如果放置了，并且假设给INVITE的应答不是415应答，那么包体的类型应当严格和INVITE请求中定义的那样
   2. 如果是415应答，那么ACK的包体应当和415应答中的Accept列出的类型一致

#### 非INVITE客户端事务

##### 非INVITE事务概览

1. 非INVITE事务并不使用ACK。他们只是简单的请求－应答的交互
2. 对于非可靠的通讯来说，请求是间隔倍增T1的时间重新传输（直到间隔时间达到T2
   1. 如果收到了一个临时应答，在非可靠通讯上，重传继续知道达到T2
   2. 只有当重传的请求收到的时候，服务端事务会重传其发出的最后一个应答，既可以是临时的应答也可以是终结应答
3. 非INVITE事务不需要对2xx应答做特别处理
4. UAC对一个非INVITE请求来说，只会产生一个单个的2xx应答

#####正式的描述

1. trying
   1. 当TU用请求来初始化一个新的客户端事务的时候，首先进入的是“trying”状态
   2. 当进入这个状态的时候，客户端事务应当初始化一个定时器F
      1. 这个定时器F应当有一个初始值64×T1秒
   3. 这个请求必须交给通讯层来发送。如果使用的是非可靠传输的通讯协议，客户端事务必须还设置定时器E，初始值是T1
      1. 如果定时器E触发了，并且还是在”trying”状态，那么定时器需要设置成为MIN(2*T1,T2)，并且重新发送
      2. 如果再次触发了，那么就再设置成为MIN(4*T1,T2)，每次都是倍增，
      3. 这个过程会一直继续，直到重发的间距是T2为止
2. terminate
   1. 如果定时器F触发了，并且客户端事务依旧是在”trying”状态，那么客户端事务应当通知TU这个超时，并且转入”terminate”状态
   2. 当事务进入终结状态，就必须立刻终止了
3. proceeding
   1. 如果在”trying”状态的时候收到了一个临时应答，那么这个应答必须转给TU处理，并且客户端事务转到”proceeding”状态
   2. 如果定时器E在”Proceeding”状态触发了，那么请求必须交给通讯层进行传输，并且定时器E必须重新设置成为T2秒
   3. 如果定时器F在”Proceeding”状态触发了，那么必须通知TU超时了，并且客户端事务必须转到终结状态
   4. 如果在”Proceeding”状态的时候收到了一个终结应答（状态码200－699），这个应答必须发送给TU，并且客户端事务必须转到”Completed”状态。
4. Completed
   1. 如果在”trying”状态收到了一个终结应答（200－699的应答码），那么应答必须交给TU，并且客户端事务必须转到”Completed”状态
   2. 一旦客户端事务进入”Completed”状态
      1. 对于非可靠传输的情况，客户端事务必须设置一个定时器K＝T4秒
      2. 对于可靠传输的情况，设置定时器K=0秒
   3. Completed状态维持的目的是为了缓冲可能会收到的其他重发的应答

#### 客户端事务匹配应答

1. 当客户端事务的通讯层收到一个应答，他必须决定是否由客户端事务来处理这个应答
   1. 在Via头域的最上边的branch参数就是用来做这个
2. 一个应答和一个客户端事务匹配的话，就有两个条件：
   1. 如果应答Via最上边的branch参数和创建这个客户端事务的请求的Via最上边的branch参数相同
   2. 如果Cseq头域的方法参数和创建事务的请求的方法相同
3. 如果一个请求是广播发送的，他可能从不同的服务器上得到不同的应答
   1. 这些应答的最上边的Via都有相同的branch参数，但是在To tag中是不同的
   2. 当收到了第一个应答，基于上边的规则，将会判定是这个客户端事务的应答，其他的应答将会视同为重发。这并不是错误的情况

#### 处理通讯错误

1. 当客户端事务发送一个请求到通讯层发送的时候，如果通讯层报告发送失败，那么需要执行下列步骤
   1. 客户端事务应当通知TU这个通讯失败，并且客户端事务应当直接转到”Terminate”状态

### 服务端事务

1. 服务端事务是用来传输请求到TU并且可靠的传输应答的
2. 服务端事务是当请求到达的时候由核心创建的，事务的处理也是主要围绕着对应请求的
   1. 也就是说并非全部都是和对应请求相关
3. 和客户端事务对应的，状态机依赖于是否接收的请求是INVITE请求。

#### INVITE服务端事务

1. proceeding
   1. 当为一个请求创建了服务端事务的时候，服务端事务进入”proceeding”状态
   2. 除非服务端事务知道TU在200ms之内会生成临时或者终结应答（在这种情况下，TU可能会产生100Trying应答），他必须生成100（Trying）应答
      1. 这个临时应答是用来停止客户端重发请求的，这个可以避免网络风暴
   3. TU可以给服务端事务任意数量个临时应答
   4. 只要服务端事务在”proceeding”状态，每个临时应答都应当交给通讯层发送
      1. 这些临时应答并非被通讯层可靠的发送（他们并不重新发送临时应答）并且临时应答并不改变服务端事务的状态
   5. 如果在”proceeding”状态，收到一个请求的重发请求，那么就需要把从TU最近收到的那个临时应答重新交给通讯层发送一次。
   6. 如果，在”proceeding”状态，TU发送了一个2xx应答给服务端事务，服务端事务必须把这个应答交给通讯层进行发送
      1. 对于2xx应答的重发是由TU处理的。服务端事务必须转到”Terminated”状态。
2. Completed
   1. 当在”Proceeding”状态的时候，如果TU交给服务端事务一个300到699的应答，那么应答必须交给通讯层进行发送，并且状态机必须进入”Completed”状态
      1. 对于非可靠传输的情况，必须设置定时器G=T1秒
      2. 对于可靠传输的情况，不设置定时器G（=0的情况就是不设置）
      3. 如果定时器G触发了，那么应答会交给通讯层再次发送，并且定时器设置成为MIN(2*T1,T2)秒。依此类推，当定时器G再次触发，那么定时器G的值会翻倍，直到T2
   2. 当进入了”Completed”状态，必须为所有的传输，设置一个定时器H＝64×T1秒
      1. 定时器H决定何时服务端事务取消重发应答
      2. 个值和定时器B的取值一样，是等同于客户端事务会重试发送请求的时间
3. Confirmed
   1. 当服务端事务在”Completed”状态的时候，如果收到了一个ACK请求，服务端事务必须转到”Confirmed”状态
   2. 定时器G会在这个状态被忽略，所有的应答重发都会被终止。
   3. 设定”Confirmed”状态的目的是为了处理任何附加的ACK消息，这是由重发的终结应答所触发的
   4. 当进入这个状态，如果是在不可靠传输协议，那么就要设定一个定时器I＝T4秒
   5. 如果是可靠传输协议，那么就设定I=0
4. Terminated
   1. 如果在”completed”状态的时候，定时器H触发了，就意味着没有收到ACK请求。在这个情况下，服务端事务必须转到”Terminated”状态，并且必须通知TU事务失败
   2. 当定时器I触发了，服务端事务必须转到”Terminated”状态。
   3. 当服务端事务状态处于”Terminated”状态，这个事务必须立刻销毁
      1. 和客户端事务一样，这是为了保证给INVITE的2xx应答的可靠性

#### 非INVITE服务端事务

1. trying
   1. 当收到一个不是INVITE或者ACK的请求的时候，状态机会初始化成为”trying”状态
      1. 这个请求会交给TU处理
   2. 当在”trying”状态，任何重发的请求会被忽略
2. Proceeding
   1. 当处于”trying”状态，如果TU交给服务端事务一个临时应答，服务端事务应当进入”Proceeding”状态
      1. 这个应答必须交给通讯层进行发送
   2. 在”Proceeding”状态下从TU收到的任何应答都必须交给通讯层进行发送。
3. Completed
   1. 如果在”Proceeding”状态下，TU交给服务端事务一个终结应答（应答码是200－699），那么服务端事务必须进入”Completed”状态，并且应答必须交给通讯层进行发送
   2. 服务端事务进入了”Completed”状态，对于不可靠传输协议来说，必须设定一个定时器J＝64×T1秒
   3. 对于可靠传输来说，设定为0秒（就是不设定定时器）
   4. 在”Completed”状态下，任何其他TU传递下来给服务端事务的终结应答都必须被抛弃
   5. 服务端事务保持这个状态直到定时器J触发，当定时器J触发了以后，服务端事务必须进入”Terminated”状态。
4. Terminated

#### 为服务端事务匹配请求

1. 当服务端从网络上收到一个请求以后，他必须和现有的事务进行判定，规则如下：
   1. 查请求中的Via头域的最上一个branch参数
      1. 如果他以”z9hG4bk”开头，那么这个请求一定是由客户端事务根据本规范产生的
      2. branch参数在该客户端发出的所有的事务中都是唯一的
   2. 请求中的最上的Via头域的**branch**参数和创建本事务的请求的最上的Via头域的branch参数一样
   3. 请求的最上的Via头域的**sent－by**参数和创建本事务的请求的最上的Via头域的send-by参数一样
      1. send-by参数被用于匹配过程，这是因为有可能存在无意/恶意的相同的不同客户端传来的branch参数
   4. 请求的方法和创建本事务的**方法**一样。这有一个例外，就是ACK,ACK对应的创建本事务的请求方法是INVITE。
   5. 这个匹配规则用于INVITE和非INVITE事务
2. 如果最上的Via头域的branch参数不存在，或者没有包含那个”z9hG4bk”，那么就用下列步骤进行判定
   1. 如果是INVITE请求，并且这个INVITE请求的Request-URI,To tag,From tag,Call-ID,Cseq,和最上的Via头域都和创建事务的INVITE请求的这些字段匹配，那么这个INVITE请求就是匹配这个事务的INVITE请求。
      1. ACK请求在匹配创建事务的INVITE请求的Request-URI, From tag, Call-ID ,Cseq序列号（非方法字段）， 最上的Via头域，并且To tag和服务端事务发出的应答的To tag相同，这个ACK就是这个事务的ACK
   2. 对于所有的其他请求方法，如果请求的Request-URI,To tag,From tag，Call-ID， Cseq（包括Cseq中的方法字段），以及Via头域的最上值，都和创建服务端事务的请求相匹配，那么这个请求就是这个事务的匹配请求
      1. 匹配是基于针对每一个头域值的判定进行的。
      2. 当非INVITE请求和现有事务匹配了，那么它就是创建这个事务的请求的一个重发。
   3. 由于匹配规则中包含了Request-URI,服务器不能匹配应答对应到事务

#### 处理通讯错误

1. 当服务端事务发送一个应答到通讯层要发送的时候，如果通讯层报告发送失败，那么就需要执行下列的步骤：
   1. 把应答发送一个备份的地点
      1. 如果这个也失败了，服务端事务应当通知TU发送失败，并且把状态切换到终止状态。

## 通讯**(transport)**

1. 通讯层负责请求和应答在网络上的实际传输。这包括了在面向连接的通讯方式下的请求和应答所使用的连接管理
2. 通讯层负责管理像TCP/SCTP之类通讯协议的长连接，或者在这些协议上的TLS连接，并且包括管理打开这些连接的使用者的管理
   1. 包括了客户端或者服务端通讯层打开的连接，这些连接采用一组用远端的地址，端口，通讯协议标志的索引来进行管理。
   2. 当通讯层打开了一个连接，这个连接的索引就设置成为远端的IP,端口,还有打开这个连接的通讯层的实例
3. 建议在实现中，当发送（或者接收）完成最后一个消息之后，依旧维持这个连接一段时间
   1. 这段时间应当是至少等于本节点的事务从创建到结束的最长时间
   2. 这是为了让事务能够在他们所创建的同一个连接上完成
4. 所有的SIP元素都必须实现基于UDP和TCP的通讯。SIP元素还可以实现其他的协议。

### 客户Clients

#### 发送请求

1. 通讯层的客户端负责发送请求和接收应答
   1. 通讯层的用户把请求交给通讯层的实例进行处理，包括IP地址端口，通讯层实例，还有可能有多点广播的TTL。
2. 如果客户端向多个地址发送请求，那么必须增加”maddr”参数到Via头域值上，并且这个参数值指定多个目的地址
3. 寻找最接近的单点”服务（”single-hop-discovery-like”）
   1. 这个服务将请求转发到一组类似的服务器，并且只需要处理其中任意一个服务器的应答
   2. 这个功能主要用于注册服务
4. 在请求发送前，客户端通讯层必须在Via头域中增加一个”sent-by”栏
   1. 这个字段包含了一个IP地址或者主机名，端口
   2. 推荐使用FQDN方法描述这个主机名
5. 对于可靠传输协议，应答通常简单的通过连接发送，并且这个连接是收到对应请求的连接。
   1. 客户端传输层必须准备在发出请求的同一个连接上接收应答
   2. 在出现错误的情况下，服务端可能会尝试新建立一个连接来发送应答
      1. 为了能够处理这种情况，通讯层必须准备接收一个从源IP建立的新连接
      2. 这个连接的IP是请求发起的源IP，port是在”sent-by”字段中指定的port
6. 对于非可靠的传输协议，客户端通讯层必须准备从发送请求的那个原始IP地址上接收应答。并且端口号是在”sent-by”字段的端口号
7. 对于多点传送的情况来说，客户端通讯层必须准备从相同的多点传输组上接收应答，这个组的地址和端口和发出请求的组相同
8. 如果请求发送的目的IP地址，端口和transport都和现有的一个连接相同，那么建议使用这个连接来发送请求，同时也允许新建立一个连接来发送。
9. 如果请求通过多点发送，那么它发送的一组地址，端口和TTL都是由通讯层的用户提供

#### 接收应答

1. 当应答接收到的时候，客户端通讯层检查最上的Via头域值
   1. 如果”sent-by”参数不符合客户端通讯层在请求中插入的值，那么这个应答必须悄悄丢弃
2. 如果由任何客户端事务存在，客户端通讯层匹配现存的事务和这个接收到的应答。
   1. 如果匹配到了，应答必须交给事务层进行处理
   2. 否则，应答必须交给核心去处理

### 服务端

#### 接收请求

1. 一个服务器应当能够接收从任何IP地址、端口和协议上过来的请求
   1. 他们是通过对这个服务器的SIP或者SIPS URI的DNS查找，得到这个服务器的地址然后连接和发送的请求的
   2. 在这里，handing out(分发)包含了在REGISTER请求或者转发应答的Contact头域中放一个URI，或者在请求或者应答的”Record-Route”头域中放一个URI。也可以通过将URI放在网页或名片上来“分发”URI
   3. 建议服务器在所有公共接口上监听默认SIP端口上的请求
      1. 对于服务器监听UDP的任何端口和界面，都必须在TCP上也进行同样的监听
         1. 可能消息还需要通过TCP进行传输，比如消息过大的情况
      2. 在相反的情况下就不需要
         1. 如果一个服务器在TCP监听了，那么它不一定需要在UDP上也进行相应的监听
2. 当服务端事务从任意一个通讯层上接收到一个请求的时候，它必须检查最上的Via头域的”sent-by”参数。
   1. 如果”sent-by”参数的主机部分包含了一个主机名，或者它包含的IP地址和包的源地址不同
      1. 服务器必须增加一个”received”参数到这个Via头域值中。这个参数必须包含收到的包的原地址
      2. 可以用来帮助服务端通讯层发送应答
3. 接着，服务端通讯层尝试和服务端事务做匹配。
   1. 如果匹配上一个服务端事务，那么请求就交给那个事务去处理
   2. 如果没有匹配到事务，请求就交给核心去处理，可能会创建一个新的服务端事务来处理
   3. 当UAS核心给INVITE请求发送一个2xx应答的时候，服务端事务已经销毁了
      1. 当ACK收到的时候，不会有匹配的服务端事务，并且基于这个规则，ACK回交给UAS核心来处理

#### 发送应答

1. 服务端事务使用最上边的Via头域值来决定把应答发送到哪里。它必须遵从如下步骤来发送：
   1. 如果”sent-protocol”是一个可靠的传输协议比如TCP或者SCTP，或者在其上的TLS
      1. 应答必须用创建这个事务的请求的连接进行发送（如果连接还存在的情况下），这要求服务端通讯层保留服务端事务和通讯层连接的相关性
         1. 如果连接不存在了服务端应当创建一个新的连接
            1. 如果存在”received”参数，就用对应的在”received”参数中指定的IP地址
            2. 如果存在”sent-by”参数，那么就用”sent-by”指定的port，如果不存在，那么就用默认的port
         2. 如果对应的连接已经失效，那么服务器应当采用附件[4]的步骤来决定使用那个IP地址和端口来建立连接并且发送应答。
   2. 否则，如果Via头域包含一个”maddr”参数
      1. 必须把应答转发到maddr所指明的地址，并且使用”sent-by”所指定的端口
         1. 如果没有sent-by参数，那么就使用5060默认参数
         2. 如果地址是一个多点地址，应答应当使用”ttl”参数所指定的TTL，或者如果没有指定”ttl”参数，则使用TTL=1的参数。
   3. 否则（对于非可靠传输），如果Via的最上头域包含一个”received”参数
      1. 应答必须发送到”received”参数所指定的地址，并且使用”sent-by”所指定的端口，
         1. 如果没有sent-by参数，那么就使用5060默认参数
   4.  否则，如果没有receiver-标记
      1. 应答应当使用附件[4]的第5节指定的步骤，送到”sent-by”参数指定的地址。

### 分块

1. 在面向消息的通讯协议中（比如UDP）
   1. 如果消息有一个Content-Length头域，那么消息体就有可能包含很多字节。
   2. 并且收到的包中除了这个消息体的Content-Length字节以外，还有通讯层附加的通讯包字节，那么这部分额外的字节应当被丢弃
   3. 如果通讯包在没有收到完整的Content-Length字节的消息体就终止了，这就意味着出错了
   4. 如果这个消息是一个应答，那么这个消息必须被丢弃
   5. 如果消息是一个请求，那么本程序应当给出一个400
   6. 如果消息没有包含一个Content-Length头域，消息体的结束点就是消息体的结束点。
2. 在面向流的通讯协议中（比如TCP）
   1. Content-Length头域标志这包体的大小。在面向流的通讯协议中，必须使用Content-Length字段。

### 错误处理

1. 错误的处理取决于出现错误的消息是请求还是应答
2. 如果通讯层的用户要求在一个非可靠传输协议上发送一个消息，并且结果是一个ICMP错误
   1. 那么错误处理的方法依赖于ICMP错误类型
3. 当通讯层遇到主机、网络、端口或者协议无法到达的错误，或者参数错误的时候，应当通知通讯层的用户发送失败
4. 如果通讯层用户要求在一个可靠传输协议上发送一个请求，并且结果是一个连接错误，通讯层应当通知通讯层用户这个发送错误

## 常见的消息部件**(Common Message Components)**

### SIP和SIPS统一资源标记

1. SIP或者SIPS 的URI用来标记一个通讯用的资源
   1. 就像其他所有的URI一样，SIP和SIPS URI可以放在网页上，email消息里，或者打印出来的名片上等等
   2. 在这些URI里边包含了足够的信息来发起和维持到这个资源的一个通讯会话。
2. 一个通讯资源的例子包含下列内容
   1. 一个在线服务的用户
   2. 一个多线电话
   3. 消息系统中的邮箱
   4. 网关服务的PSTN电话号码
   5.  一个组织中的一个部门
3. SIPS URI定义了对资源的访问是安全的
   1. 从资源的主机到用户之间的通讯是加密安全的，这个安全机制是依赖于主机的实现的
   2. 何用SIP URI描述的资源，只要想通过加密的形式进行通讯，都可以通过简单改变一下资源描述府就可以”升级”成为一个SIPS URI

#### SIP和SIPS部件

1. “sip:”和”sips:”使用类似mailto URL的格式定义，允许有SIP请求头域字段和SIP消息体的规范。
   1. 这使得在网页上或者email中，可以用URI来初始化一个会话
   2. 这个会话有特定的主题，媒体类别，紧急类型
2. 一个SIP URI的通常格式是这样的：
   1. `sip: user:password@host:port;uri-parameters?headers`
   2. SIPS用”sips”来代替sip。
   3. user： 这是在主机的特定资源地址；如果SIP/SIPS URI中存在@符号，user字段不能为空；如果被寻址的主机可以处理电话号码，可以使用电话用户字段来填充
   4. host在这里通常指的是一个域名
   5. URI中的”userinfo”：用户字段，密码字段和跟随它们的@符号组成；userinfo是可选的(目标主机没有用户的概念，或者主机本身是被识别的资源)
   6. password：password字段是和用户相关的
      1. 这种用法我们是不推荐的，因为把身份认证信息放在明码表示的地方（比如URI）会带来很大的安全风险
      2. 密码字段只是一个用户信息扩展的一部分
   7. host：主机提供了SIP资源；
      1. host部分包含了一个完整的主机名字或者IPV4/IPV6的地址。我们强烈建议如果可能，就使用完整格式的主机名字。
   8. port： 端口号是请求将被送出的端口。
   9. URI 参数：请求将使用这个URI来构造
      1. URI参数在hostport部件之后增加，用分号分开。
      2. URI参数有如下格式：
         1. parameter-name "=" parameter-value
      3. 虽然在同一个URI中允许有任意多个URI的参数，但是同一个参数名只能出现1次。
      4. 这个扩展机制包括了transport，maddr,ttl,user,method和lr参数
         1. transport参数决定发送SIP消息的通讯机制
            1. SIP可以使用任何网络通讯协议。参数名字是为UDP和SCTP定义的
            2. 对于一个SIPS URI,transport参数必须指向一个可靠的通讯协议。
         2. maddr参数指明了联系这个用户的服务器的地址，它会覆盖在host域中的地址
            1. 当给定了一个maddr参数，URI中的port和transport部件将会在maddr中指出
            2. maddr字段用作简单的去掉源路由的方法来使用的
         3. ttl参数决定了UDP多点报文的生存周期，并且只能用于maddr是一个多点地址并且通讯协议是UDP的情况
      5. 用用户URI参数来区别电话号码和用户名（长得像电话号码的用户名）
         1. 如果用户串使用了电话号码描述的字串，用户参数值”phone”应当增加
      6. 从URI中构建SIP请求所需要的method域，可以由method参数指定
      7. 如果指定了lr参数，就标志着这个资源的拥有者是根据本规范来实现的路由机制。
      8. 由于URI参数机制是可以扩展的，SIP元素应当悄悄跳过那些不认识的uri参数。
   10. Headers：头域是从给定URI创造的请求的头域部分
       1. 在SIP请求中的头域可以在URI中用”?”来给出
       2. 头域名(hname)和头域值(hvalue)都是用&符号间隔的头域名=头域值的格式。

#### 字符转码要求**Character Escaping Requirements**

1. 当需要把字符串封装到SIP URI的时候，使用””%” HEX HEX”机制来进行转码
2. 对于每一个部件来说，由BNF扩展的合法字符集合规定了那些字符是可以不经转码的。其他字符都必须经过转码
3. user部件的电话描述(telephone-subscriber)部分由特别的转码考虑
4. 注意在SIP或者SIPS URI中，host部分不允许做字符的转码

#### SIP和SIPS URI例子

#### URI比较

1. 部分操作需要比较两个SIP或者SIPS URI是否相等。SIP和SIPS URI根据如下步骤进行比较：
   1.  SIP和SIPS URI永远不等
   2. SIP/SIPS URI的userinfo是大小写敏感的
      1. 包括了含有password或者按照电话描述格式的userinfo的比较
   3. 参数的顺序和头域的顺序对于比较SIP/SIPS URI不起作用
   4. 在保留字符集之外的字符等同于他们的””%” HEX HEX”格式
   5.  IP地址就算是等同于通过DNS查找到的主机名对应的IP地址，IP地址也不能和主机名等同
   6.  两个URI如果相同，那么user，password，host，port部分必须相同
   7. 有user部分的URI和没有user部分的URI是不相等的，有password部分的URI和没有password部分的URI也是不同的
   8. 一个不带可选部件的URI和带了这些部件但是值是默认值的URI是不等的
   9. URI uri参数部件按照如下规则进行比较
   10. 任何在两个URI中出现的uri参数都必须一样	
   11. user,ttl,或者方法uri参数如果只在一方出现，即使和默认值相等，也判定为两个URI不相等。
   12.   包含maddr参数的URI和没有包含maddr参数的不相等
   13.  其他uri参数，如果在一方出现，则在比较的时候忽略
   14. URI头部件的比较是不能忽略的。任何在header部分出现的域都必须在双方URI中进行匹配和比较

#### 从URI中产生请求

1. 对于实现而言，需要能够直接从一个URI来构造请求；URI可以是从名片，网页，或者甚至从某些协议内部得到
2. 协议的实现必须包括构造请求的Request-URI中的transport,maddr,ttl,或者user参数
   1. 如果URI包含了method参数，那么它的值必须和构造的请求的方法一样。且method参数不能放在Request-URI中
   2. 不认识的URI参数必须放在消息的Request-URI中。
3. 实现中应当把URI中出现的header或者包体部分包含入消息本身，并且当作是请求自己的组成部分
4. 在实现中，不应当保留那些明显危险的头域字段：From,Call-ID,Cseq,Via和Record-Route。
5. 并且实现中，也不应当保留任何请求的Route头域值
   1. 这样可以避免无知的客户端进行恶意攻击。
6. 实现中也不应当保留那些可能会导致错误登记地址或者误导能力的头域字段
7. 实现上应当检查每一个请求中所描述的头域的正确性
8. 如果从给定URI构造的请求不是一个合法的SIP请求，那么这个URI就是非法的URI
   1. 实现上禁止处理和传送非法的SIP请求。它应当尝试追查为何会有一个非法的URI。
   2. 很多情况都可以得到一个非法的请求。这包括但是不限于，头域的语法错误，非法的URI参数合并，或者错误的消息体描述等等
9. 发送从URI构造的请求可能会导致实现上的能力不够

#### 关联SIP IRO和tel URL

1. 如果tel URL(RFC 2806[9])转换成为一个SIP或者SIPS URI,那么tel URL的整个电话描述（telephone-subscriber），机器参数，都需要放在SIP或者SIPS URI的userinfo部分。
2. 通常来说，相等的”tel”URL转换成为SIP或者SIPS URI以后，不一定能得到相同的SIP或者SIPS URI
   1. 由大小写不敏感的tel URL以及重新排序的tel URL参数并不改变tel URL的相等性，但是在转换成为SIP或者SIPS URI之后，却影响了他们的相等性。
   2. 为了避免这个问题，在构造放在SIP或者SIPS URI中的userinfo部分的电话描述域的时候
      1. 应当转换大小写不敏感的电话描述域为小写
      2. 除了isdn-subaddress和post-dial,把电话描述的参数按照参数名进行排序

### Option Tgas

1. Option tags是一个唯一标志，用来指明SIP中的新options（扩展）的
   1. 这些tags在Require,Proxy-Require，Supported和Unsupported头域中使用。
   2. 这些options是以option-tag=的形式作为这些头域的参数存在的

### Tags

1. “tag”参数用于SIP消息中的To和From头域
2. 作为一个通用的机制的一部分来唯一标志一个对话，这个机制用Call-ID和两个从对话参与者的tag来标志一个对话
3. 当UA在对话外发出一个请求时，
   1. 它只包含了From tag,提供了对话ID的”一半”;对话根据应答创建完成，这个应答在To头域	中提供了对话ID的另一半。
   2. SIP请求的分支意味着一个单个请求可以创建多个对话
   3. 如果没有被叫方的标志，呼叫方不能分辩和消除由单个请求创建的多个对话。
4. 当UA产生一个tag并且增加进一个请求或者应答的时候，它必须是一个全局唯一的，并且是密码随机数起码是32位的随机数。
   1. 为了让UA能够在同一个INVITE请求中，在给这个INVITE的应答中，在To头域产生一个不同的tag
5. 在全局唯一要求之外，产生tag的算法是实现相关的
6. Tag对于容错系统比较有用，在容错系统下，当主服务器故障的时候，对话会在另外一个服务器上进行恢复
   1. AS可以产生一个tag，让备用服务器能够认识到这个请求是在故障服务器上的对话，并且能够决定是否恢复对话和对话相关的状态。

## 头域

1. where：描述了在头域中能够使用的请求和应答的类型
   1. R:头域只能在请求中出现；
   2. r:头域只能在应答中出现
   3. 2xx，4xx，等等：一个数字的值区间表示头域能够使用的应答代码。
   4. c：头域是从请求拷贝到应答的
   5. 如果”where”栏目是空白，表示头域可以在所有的请求和应答中出现
2. proxy：描述了proxy在头域上的操作
   1. a：如果头域不存在，proxy可以增加或者连接头域
   2. m：proxy可以修改现存的头域值
   3. d：proxy可以删除头域值
   4. r：proxy必须能读取这个头域，因此这个头域不能加密。
3. Optional
   1. 意味着这个元素可以在请求或者应答中包含这个头域，并且UA可以忽略在请求或者应答中存在的这个头域
   2. 有一个例外，就是Require头域
4. mandatory”（强制）头域是必须在请求中存在的头域，并且也必须是UAS接收到一个请求时能够理解的头域
   1. 一个强制头域必须也在应答中出现，并且UAC也能处理这个头域
5. Not applicable”（不适用）意味着头域不能在请求中出现
   1. 如果一个UAC错误的把这个头域放在请求中，在UAS收到的时候必须被忽略。同样的，如果应答中的”不适用”的头域，也就是说UAS不能在应答中放置的头域，如果出现了，那么UAC也必须在应答中忽略掉这个头域
6. 接下来的六列与方法中存在头字段有关
   1. c：条件；对头域的要求依赖于消息的内容
   2. m：头域是强制要有的。
   3. m*：头域应当被发送，但是客户端/服务端都需要准备接收没有这个头域的消息。
   4. o：头域是可选的。
   5. 头域应当被发送，但是客户端/服务端都需要准备接收没有这个头域的消息
      1. 如果通讯的协议是基于面向流的协议（比如TCP），那么头域值必须被发送。
   6. *：如果消息体不为空，那么头域值就绪要的
   7. -:这个头域是不适用的
7. 一个UA必须忽略他们所不能处理的扩展的头参数。
8. 在Contact，From，To头域中都包含一个URI
   1. 如果这个URI包含一个逗号，问号或者分号，那么这个URI必须使用尖括号括起来（<和>）
   2. 所有的URI参数都必须在这些括号内

### Accept

1. 除了如果没有Accept头域，服务器应当认为Accept默认值是application/sdp以外，空的Accept头域意味着不接受任何格式

### Accept-Encoding

1. Accept-Encoding头域类似Accept，但是限定了接收应答中的内容的编码
2. 一个空的Accept-Encoding头域是允许的
   1. 等同于Accept-Encoding:identity,这就是说，只有identity编码，也就是说没有编码的情况，是允许的
3. 如果没有Accept-Encoding头域存在，那么服务端应当使用默认值：identity。

### Accept-Language

1. Accept-Language头域用来在请求中指定首选的的语言
   1. 首选的语言是在应答中的消息体中的的原因分析，会话描述，或者状态报告的
   2. 如果没有Accept-Language存在，那么服务端应当假设所有的语言客户端都可以接受。

### Alert-Info

1. 当INVITE请求有一个Alert-Info头域的时候，Alert-Info头域就包含的是给UAS的一个额外的信息
   1. 当在180（Ringing）应答中出现的时候，Alter-Info头域给出了UAC一个额外的回铃信息
2. Alter-Info头域可能会带来潜在的安全隐患。

### Allow

1. Allow头域列出了UA支持的方法列表
   1. 如果要提供UA头域，那么所有只要是UA支持的方法，包括ACK和CANCEL都必须列在这个Allow头域中
   2. 如果没有Allow头域出现，一定不能以为UA什么方法都不支持；应当解释成为发送这个消息的UA并没有告诉大家它支持什么方法。
2. 在应答中提供Allow头域比在OPTIONS请求/应答中会减小所需要的消息数量

### Authentication-Info

1. Authentication-Info 头域提供了和HTTP类别相同的认证方法
   1. UAS可以在给一个顺利通过认证的请求的2xx应答中包含这个头域，并且是使用基于Authorization头域的分类

### Authorization

1. Authorization头域包含了了UA进行认证的信任书
2. 这个头域，和Proxy-Authorization,并不遵循通常的多头域值的规则
   1. 虽然它不是由逗号分割的列表，这个头域名可以出现多次，并且不能应用7.3节的规则合并成为单个头域。

### Call-ID

1. Call-ID头域用来唯一区别一个特定的邀请或者一个特定客户端的所有注册项
   1. 单个多媒体会议可以分解成为多个不同Call-ID的呼叫
   2. Call-ID头域的简写就是i

### Call-Info

1. Call-Info头域提供了对呼叫方或者被叫方的附加信息
   1. 如果出现在请求中则是呼叫方的信息，如果出现在应答中则是被叫方的
   2. purpose参数中存放了效果图URI
   3. icon”参数包含了一个呼叫方或者被叫方的图标
   4. info”参数描述了简要的呼叫方或者被叫方的信息
2. 对Call-Info的使用可能会带来一些安全隐患

### Contact

1. Contact头域提供了一个URI，这个URI的含义取决于是在请求还是在应答中。
2. Contact头域包含了一个显示的名字，一个包含参数的URI，还有header参数组成。
3. Contact参数”q”和”expires”
   1. 只有当Contact头域在REGISTER的请求或者应答，或者3xx的应答中才有效
4. 即使”display-name”是空的，如果”addr-spec”包含一个逗号或者分号，或者？的话，也必须使用”name-addr”的格式。
5. 这些关于显示名字，URI和URI的参数，header参数的规则同样对To和From头域适用
6. Contact头域的的角色很像HTTP中的Location头域的角色
7. Contact头域的缩写是m

### Content-Disposition

1. Content-Disposition头域描述了消息体，或者消息的多个部分，或者消息体的一个部分应被UAC或者UAS怎样解释
   1. 这个SIP头域扩展了MIME Content-Type
2. SIP定义了Content-Disposition几个新的”disposition-types
   1. ”session”意味着消息体位呼叫（calls）或者早期（pre-call）媒体，描述了一个会话
   2. render”表示了消息体可是被显示或者展示给用户
      1. render”比”inline”更适合避免MIME消息体作为一个大的消息的一部分做展示
3. 如果Content-Disposition头域不存在，服务器应当假设Content-Type为application/sdp的部属方式是”session
4. icon”表示消息体部分包含了一个用于表示呼叫者或者被叫者的icon图像，当UA收到这个消息，就可以展示一下，或者在对话过程中一致展示
5. alert”意味着消息体部分包含了信息，比如是一段声音，应当由UA展示给用户提示用户这个请求
6. 所有需要展示给客户的具有”disposition-type”的MIME消息体，都应当只在这个消息有适当的安全认证的时候展示。
7. 处理参数，handling-param,描述了UAS在接收到这个内容类型或者部属类型是它所不支持的消息体的时候，应当如何操作
   1. 这个参数定了了”optional”和”required”两个值。如果处理参数没有，那么这个处理参数默认值就是”required
8. 如果这个头域不存在，那么MIME类型决定了默认的内容部属。如果没有MIME类型，那么默认值就是”render”

### Content-Encoding

1. Content-Encoding头域是对”media-type”(媒体类型)的一个修正
   1. 当存在这个头域的时候，它的值就是对包体内容编码的附加说明
   2. 因此必须根据本字段应用正确的解码机制，这样才能得到正确的Content-Type头域指出的媒体类型的解码
   3. Content-Encoding首要应用于在不丢失媒体类型标记的情况下对消息体进行压缩处理
2. 如果包体应用了多个编码，那么包体编码必须按顺序在这个字段中进行列出
3. 所有的Content-Encoding的值都是大小写不敏感的
4. 客户端可以在请求中进行包体的内容编码。服务端也可以在应答中进行内容编码
   1. 服务端必须只能应用客户端在请求中的Accept-Encoding头域中列出的编码类型
5.  Content-Encoding简写是e

### Content-Language

### Content-Length

1. Content-Length头域标志了消息体的大小，给消息的接受者，以10进制表示的数字
   1. 应用程序应当使用这个字段标志的大小来传送消息体，而不关心消息体的媒体类型是什么
   2. 如果是基于流的通讯协议（比如TCP），那么本头域必须提供。
2. 消息的大小并不包含CRLF分开的头域和包体
3. 对Content-Length的忽略能够简化创建一个类似cgi一样动态生成应答的脚本
4. 这个头域的简写是l

### Content-Type

1. Content-Type头域标志了发给对方的消息体的媒体类型
2. 如果消息体不为空，那么Content-Type头域就必须存在
3. 如果消息体是空的，并且本头域存在，那么就表示了特定类型的媒体的包体是0长度（比如空的音频文件）。
4. 本头域的简写是c

### Cseq

1. 请求中的Cseq头域包含了一个单个的数字序列号和请求的方法
   1. 这个序列号必须是表示成为一个32位的无符号整数
   2. 在Cseq的请求方法部分是大小写敏感的
2. Cseq头域是为了在会话中对事务进行排序的，提供事务的唯一标志，并且区分请求和请求的重发。
3. 。如果序列号相等，并且请求的方法相等，那么两个Cseq头域就是相等的

### Date

1. Date头域包含了日期和时间
2. Date头域可以用来简化没有后备电池的终端系统，让他们能够获得当前的时间
   1. 由于是GMT格式的，所以，它要求客户端知道和GMT的时差。

### Errot-Info

1. Error-Info头域提供了对有错误应答码的应答的附加信息
2. UAC可以把在Error-Info中的一个SIP或者SIPS URI当作是转发的一个Contact地址，并且据此产生一个新的INVITE，这样可以建立预先录制的声明会话
   1. 如果是非SIP URI，那么可以展示给用户。

### Expires

1. Expires头域给定了消息（或者内容）过期的相关时间
2. 这个头域的值是一个以秒计数的整数，从0到(2**32)-1，从收到请求开始计数。

### From

1. From头域表示了请求的来源地
2. 选项”display-name”是展示给界面的。如果客户标志停留在隐藏状态，那么系统应当使用”Anonymous”作为显示名字
   1. 即使是”displayname”是空的，如果”addr-spec” 包含一个逗号，？，或者分号，那么就必须使用”name-addr”格式。
3. 如果From的URI相等，并且参数也相等，那么这两个头域就是相等的
4. 如果扩展参数在一个头域中存在，但是在另外一个头域中不存在，那么当这两个头域做比较的时候，这个参数将被忽略
   1. 显示名字的存在与否不影响比较的结果。
5. From头域的简写是f

### In-Reply-To

1. In-Reply-To头域列举了本次呼叫相关的或者返回的Call-ID
   1. 这些Call-ID可以备客户端cache起来，这样可以在这个头域中返回

### Max-Forwards

1. Max-Forwards头域必须在任何一个SIP请求中使用，来限制中间转发请求到下一个节点的proxy或者gateway的个数
   1. 这个在客户端trace一个请求，如果路由失败或者在中间出现循环的时候特别有用。
2. Max-Forwards是一个0－255的整数，表明了在这个请求消息中允许被转发的剩余次数
   1. 每当服务器转发这个请求一次，这个数字就减一
   2. 建议的初始值是70
3. 当不能确定有无循环路由的时候，必须在头域中增加本头域

### Min-Expires

1. Min-Expires头域包含了一个服务器所支持的内部状态（soft－state）的最小的刷新时间间隔
   1. 包括被登记服务器所登记的Contact头域
   2. 包含了一个以秒计数的整数，从0到(2**32)-1。在423（Interval Too Brief）应答中

### MIME-Version

### Organization

1. Organization头域包含了发出请求或者应答的SIP节点所属的组织名字
   1. 这个字段可以用来让客户端软件过滤呼叫

### Priority

1. Priority头域标志了客户端评价的请求紧急程度
   1. 描述了SIP应当处理人工或者UA发过来的请求的优先级
   2. 可能是决定呼叫转发和处理的优先要素
   3. 如果消息没有包含Priority字段，那么处理的时候应当当作”normal”优先级处理
2. Priority头域不影响通讯资源的优先顺序
3. 强烈建议”emergency”只用于影响到生命、身体、或者财产危急时候才使用

### Proxy-Authenticate

1. Proxy-Authenticate头域用来进认证使用的

### Proxy-Authorization

1. Proxy-Authorization头域允许客户端向一个要求认证的proxy证明自己（或者证明它的使用者）的身份
   1. 一个Proxy-Authorization头域包含了与UA认证信息相关的信任书，这个信任书是给proxy和/或者本请求相关的域的。
2. 本头域，连通Authorization头域，并不遵循常用的多头域名（多个相同头域名的合并）的规则

### Proxy-Require

1. Proxy-Require头域用来表示请求中一定要求proxy支持的相关的特性

### Record-Route

1. Record-Route头域是proxy在请求中增加的，用来强制会话中的后续请求经过本proxy的

### Reply-To

1. Reply-To头域包含了逻辑上返回目的地URI
   1. 可以和From头域不同
2. 即使”display-name”是空的如果”addr-spec”包含了逗号、问号、或者分号，那么就需要使用”name-addr”的格式来填写

### Retry-After

1. Retry-After头域可以用于500或者503应答
   1. 用来标志大约本服务还会处于不可用状态多久
2. 在404,413, 480,486, 或者603应答中用于标志何时被叫方会恢复正常
3. 这个字段的值是一个秒为单位的正整数（十进制），从应答生成开始的一个正整数。
4. 对于回叫的时间，可以有一个附加的说明。”duration”参数标志了被叫方变成正常状态的时间长度
   1. 如果没有定义，那么服务可以被看作是永远有效。

### Route

1. Route头域用于强制一个请求经过一个proxy路由列表

### Server

1. Server头域包含了关于UAS处理请求所使用的软件信息
2. 服务器的特定软件版本可能会使服务器由于特定软件安全漏洞导致服务器收到攻击
3. 实现上应当使得Server头域是一个可以配置的选项。

### Subject

1. Subject头域提供了呼叫的一个概览，允许呼叫不用分析会话描述就可以大致过滤
2. 会话描述并不需要和INVITE邀请使用相同的主题标志
3. Subject的缩写是s

### Supported

1. Supported头域列举了UAC或者UAS支持的扩展。
2. Supported头域包含了一个option tag的列表，他们是这个UAS或者UAC所支持的
3. 如果本字段是空的，意味着不支持任何扩展。

### Timestamp

1. Timestamp头域描述了当UAC发送请求到UAS的时间戳

### To

1. To头域定义了逻辑上请求的接收者
   1. 选项”display-name”意味着展示给客户的界面
   2. ”tag”参数提供了对话识别机制
2. 对于To头域的比较是和对From头域的比较相同的
3. To头域的缩写是t。

### Unsupported

1. Unsupported头域列出了不被UAS支持的特性列表

### User-Agent

1. User-Agent头域包含了发起请求的UAC信息
2. UA所使用的版本号情况可能会导致由于这个版本的安全漏洞二遭受攻击
3. 在实现上应当使得User-Agent头域是可以配置的

### Via

1. Via头域是用来描述请求当前经历的路径的，并且标志了应答所应当经过的路径
   1. Via头域的branch ID参数提供了事务的标志，并且用于proxy来检查循环路由
2. Via头域包含了用于发送消息的通讯协议，客户端主机名或者网络地址，可能还有接收应答所用的端口号码。
   1. Via头域还可以包含参数”maddr”,”ttl”,”received”和”branch
3. Via头域的缩写是v
4. 本头域的BNF描述中，branch参数是可选的
5. 发送协议和sent-by域相等，都有相同的参数集合，并且参数都相等，那么两个Via头域就是相同的

### Warning

1. Warning头域用来给应答的状态添加附加说明使用的
   1. Warning头域值是在应答中包含的，并且包括了一个3位的警告代码，主机名，和警告正文
2. “warn-text”应当是一个自然语言，给个人用户接收应答时候来响应的
3. 警告信息300到329是保留用于标志在会话描述中的保留字错误的，330到339是会话描述中基本网络服务相关警告，370到379是关于会话描述重的QoS参数数量相关的警告，390到399是上边未列除的杂项警告信息。

### WWW-Authenticate

1. WW-Authenticate头域包含了认证信息

## 应答代码

1. 应答码是包含了，并且扩展了HTTP/1.1应答码
   1. 并不是所有的HTTP/1.1应答码都适当应用
2. SIP也定义了新的应答码系列，6xx。

## 使用HTTP认证

1. SIP为认证系统提供了一个无状态的，试错机制，这个认证机制式基于HTTP的认证机制的。
   1. 任何时候proxy服务器或者UA接收到一个请求，它尝试检查请求发起者提供的身份确认
   2. 当发起方身份确认了，请求的接受方应当确认这个用户是否式通过认证的
2. Digest”认证机制，只提供了消息认证和复查保护，没有提供消息完整性或者机密性的保证
3. 不赞成”Basic”（基本的）认证方法
   1. 服务器必须不能接收验证方法式”Basic”类型的信任书，并且服务器必须拒绝”Basic”

### 框架

1. SIP认证的框架和HTTP非常接近
   1. auth-scheme的BNF范式，auth-param,challenge,realm,realm-value,以及信任书都是一样的
   2. 在SIP，UAS使用401应答来拒绝UAC的身份
   3. 注册服务器，转发服务器可以使用401来应答身份认证
   4. proxy必须不能用401，只能用407应答
2. SIP并没有一个规范的root URL的概念
   1. 需要保护的空间的概念在SIP中的解释也不一样
   2. realm字串单独定义被保护的区域
3. 被保护的区域回导致一定程度的混乱
   1. 因为Request-URI是UAC发送的，并且接收到Request-URI的认证服务器可能是不同的
   2. 真正的最终的Request-URI的格式可能对UAC并不知道
4. 需要鉴别接收到的请求的UA使用者或者proxy服务器，必须根据下边的指导来为他们的服务器创建一个realm字串。
   1. Realm字串必须是全局唯一的。我们强调这个realm字串必须包含一个主机名或者域名
   2. Realm字串应当是一个可读的能够展示给用户的字串
5. SIP认证对于特定realm（一个保护区域）是有意义的
   1. 对于Digest认证来说，每一个类似的保护区域都有自己的用户名和密码集合
   2. 如果服务器对特定请求没有要求认证，那么它可以接收默认的用户名,”anonymous”,并且这个用户名没有密码（密码是””）
   3. ,代表多个用户的UAC，比如PSTN网关，可以有他们自己的设备相关的用户名和密码，而不是每一个用户名一个用户名密码
6. 两类请求要求特别的认证处理
   1. ACK
   2. CANCEL
   3. 一个服务器接受在INVITE请求中的信任书，也必须同样接收对应ACK的信任书
   4. UAC通过赋值所有的INVITE请求中的Authorization和Proxy-Authorization头域值来创建一个相关的ACK消息。服务器必须接收这个ACK请求。
7. 虽然CANCEL方法具有应答（2xx），服务器必须不能拒绝CANCEL请求
   1. 因为这些请求不能被重新提交
8. 当UAC接收到验证拒绝，并且UAC设备并不知道realm验证失败的具体原因，它必须展示给用户，验证失败的”realm”参数内容
9. 即使一个UAC能够定位与相关realm匹配的信任书，也有可能存在这个信任书可能不在有效，或者某个服务器会用什么原因不接受这个信任书
   1. 在这种情况下，服务器可能会继续拒绝，或者返回一个403
   2. UAC必须不能再次使用刚才被拒绝的信任书进行尝试

### 用户到用户的认证

1. 当UAS收到一个UAC发起的请求
   1. UAS在请求被处理之前进行身份认证
      1. 如果请求中没有信任书，UAS可以使用401拒绝认证，并且让客户端提供一个认证书。
2. WWW-Authenticate应答头域必须在401应答消息中出现
   1. 这个头域值包含了至少一个表明认证方式和适用realm的参数的拒绝原因。
   2. 当原始请求的UAC接收到这个401
      1. 如果可能的话，他应当重新组织这个请求，并且填写正确的信任书。
      2. 在继续处理之前，UAC可以要求原始用户输入信任书
      3. 一旦信任书提供了，UA应当把这个给特定To头域和”realm”字段的信任书cache起来，以备给这个地址下一个请求时候使用
      4. 如果没有找到对应realm的信任书，UAC应当尝试用用户”anonymous”和空口令来重新尝试这个请求。
      5. 一旦找到了一个信任书，那么UA应当要求在UAS或者注册服务器上认证自己，这是通常的情况
      6. 当UAC在接收到401或者407应答之后，重新用它的信任书来提交请求，它必须增加Cseq头域的值

### Proxy到用户的认证

1. 当UAC发送一个请求到proxy服务器
   1. proxy服务器可以在处理请求之前，验证原始请求的认证。
   2. 如果请求中没有信任书proxy可以用407拒绝这个原始请求，并且要求客户端提供适当的信任书
      1. proxy必须在407应答中增加一个Proxy-Authenticate头域，并且在这个头域中给出适用于本proxy的认证资源。
2. 建议使用下列步骤来cache一个proxy的信任书：
   1. 如果UA在给特定Call-ID的请求的401/407应答接收到一个Proxy-Authenticate头域
      1. 应当合并对这个realm的信任书，并且为以后具有相同Call-ID的请求发送这个信任书
      2. 这些信任书必须在对话中被cache住
   2. 过如果UA配置的是它自己的本地外发proxy，那么如果出现要求认证的情况，那么UA应当cache住跨对话的信任书
      1. 意味着在一个对话中的请求可以包含在Route头域中所经过proxy都不需要的信任书。
3. 任何希望在proxy服务器上认证的UA――通常，但是并非必须，在接收到407（Proxy Authentication Required）应答之后――可以在请求中增加一个Proxy-Authorization头域然后再次尝试
   1. Proxy-Authorization请求头域允许客户端像proxy来证明自己（或者使用者）的身份
4. 一个Proxy-Authorization头域值只提供给指定proxy验证的，这个proxy的realm是在”realm”参数中指明的
   1. 当多个proxy组成一个链路的时候，如果proxy的realm和请求中的Proxy-Authorization头域的”realm”参数不匹配，那么这个proxy就不能使用本Proxy-Authorization头域值来验证。
5. 如果一个认证机制不支持Proxy-Authorization头域的realm，porxy服务器必须尝试分析所有的Proxy-Authorization头域值来决定是否其中之一有这个proxy认为合适的信任书
6. 如果一个请求被分支，可能对同一个UAC有不同的proxy服务器和/或者UA希望要求认证
   1. 分支的proxy服务器有责任把这些被拒绝的认证合并成为一个应答
   2. 每一个分支请求的应答中接收到WWW-Authenticate和Proxy-Authenticate头域值必须由这个分支proxy放置在同一个应答中发送给UA；这些头域值的顺序并没有影响。
7. 当proxy服务器给一个请求发出拒绝认证的应答，在UAC用正确的信任书重新发请求过来之前，不会转发这个请求
   1. 分支proxy可以同时向多个要求认证的proxy服务器转发请求
   2. 每一个proxy在没有接收到UAC在他们各自的realm的认证之前，都不会转发这个请求
   3. 如果UAC没有给这些失败的验证提供信任书，那些发出拒绝通过认证的proxy是不会把请求转发给UA的目标用户的
8. 当针对包含多个拒绝认证的401或者407应答重新提交请求时，UAC应当对每一个WWW-Authenticate和Proxy-Authorization头域值提供一个信任书
9. 在同一个401或者407应答中，可能包含对同一个realm的多个验证拒绝。

### Digest认证方案

1. 描述了对HTTP Digest 认证方案的SIP修改和简化，SIP使用了和HTTP[17]几乎完全一样的方案
2. SIP服务器必须不能接收或者发出Basic认证请求
3. Digest认证的不同
   1. URI有着如下的BNF：URI=SIP-URI/SIPS-URI
   2. 对于SIP来说，’uri’参数必须在引号中引起来
   3. digest-uri-value的BNF是：digest-uri-value=Request-URI;
   4. 对SIP来说，产生基于Etag的nonce的步骤例子不适用
   5. 对SIP来说，RFC2617[17]关于chache操作不适用
   6. 在SIP中，请求行的URI和Authorization头域的URI可以指向不同的用户，因为是同一个proxy转发的
      1. 在SIP，一个服务器应当检查在Authorization头域值的Request-URI和服务器希望接收请求的用户是否一致，但是如果两者不一致，并无必要展示成为错误
   7. 关于计算消息完整性保证的A2值的一个澄清，实现着应当假定，当包体是空的（也就是说，当SIP消息没有包体）应当对包体的hash值产生一个M5hash空串，或者：
   8. 允许使用Authentication-Info头域
      1. 因为他提供了对包体的完整性检测以及提供了相互认证

## S/MIME

1. SIP消息可以加载一个MIME 消息体，并且MIME标准包括了MIME内容的保密机制
2. 实现中应当注意，不管怎样，也会有很少的网络节点（不是典型的proxy服务器），会依赖于查看修改SIP消息
   1. 采用加密的MIME可以防止这类网络节点操作。

### S/MIME认证

1. 用于区别服务器使用的S/MIME而进行的最终用户的鉴定
2. 这些信任状的持有者是被最终用户地址鉴定的，而不是由一个特定的hostname所鉴定的
   1. 这个地址是由SIP或者SIPS URI的”userinfo””@”和”domainname”组成的
   2. 最常见的就是和用户的address-of-record对应的地址。
3. 这些认证也同样和用于标记或者加密SIP消息包体的密钥相关联
   1. 包体由发送方的私钥所标记
   2. 包体是由被接受方的公钥所加密
   3. 发送方必须事先知道接受方的公钥，这样才能加密包体
4. 每一个支持S/MIME的UA都必须包含用于终端用户验证的一个特定密钥组
   1. 这个密钥组应当由address-of-record和相应的认证信息的映射组成
   2. 在时间上，当用户产生具有相同address-of-record的原始的信号URI（From头域）时，用户应当使用相同的认证信息
5. 目前没有一个统一的权威认证机构为终端用户应用提供认证
   1. 用户应当从已知的公共认证机构获得认证
   2. 用户可以创建自标记(self-signed)的信任书
6. 在获得终端用户的认证问题上，很少有广为人知的集中发布终端用户认证的目录机构

### **S/MIME 密钥交换**

1. SIP自身可以根据下列的方法发布公钥。
   1. 无论何时SIP的S/MIME使用了CMS SignedData消息，他必须包含由公钥所加密的信任书，用于检查签名
   2. 当UAC发送一个创建对话的请求，包含了一个S/MIME包体，或者在对话外发送一个非INVITE请求，UAC应当创建一个S/MIME‘multipart/signed’ CMS SignedData包体结构的包体。
   3. 如果特定的CMS服务时EnvelopedData(并且知道目标用户的公钥)，UAC应当在一个SignedData消息中发送EnvelopedData消息。
2. 当UAS接收到一个包含S/MIME CMS包体的请求，并且这个包体包含一个信任书
   1. UAS应当首先检查这个信任书，如果可能，使用以后的root信任书来进行信任书检查
   2. UAS也应当检查信任书的主题（subject）并且，把这个值和请求From头域进行比较
   3. 如果信任书不被通过UAS必须把这个通知用户，并且在继续处理之前，要求用户确认
   4. 如果信任书成功通过认证，并且信任书的主题（subject）和SIP请求的From头域相同，或者如果用户（在知会之后）批准了这个信任书的使用，那么UAS应当增加这个信任书到本地密钥组中，并且用信任书拥有者的address-of-record作为索引。
3. 当UAS要发送一个包含S/MIME消息体的应答
   1. 这个应答回应了在对话中的前一个请求，或者是给对话外的一个非INVITE请求的应答，
   2. UAS应当构造一个S/MIME ‘multipart/signed’ CMS SignedData包体
4. 当UAC收到一个包含S/MIME CMS包体的应答，这个应答中包含了一个信任书
   1. UAC应当首先检查这个信任书，如果可能，使用任何适当的root信任书来进行检查
   2. UAC应当同样检查信任书的主题（subject）并且和应答的To头域进行比较；
   3. 如果因为self-signed,或者由未知认证机关颁发而导致信任书不能通过认证，UAC应当通知它的使用者这个状态并且在继续操作之前，要求使用者确认
   4. 如果信任书通过了认证，并且信任书的主题和应答的To头域相同，或者用户（在提示确认后）明确的确认这个信任书以后，UAC应当把这个信任书放在本地密钥组中，用这个信任书的拥有者的address-of-record作为索引
5. 在以后，当UA接收到包伙那一个From头域的请求或者应答，并且这个From头域和本地的一个密钥组的索引匹配，那么UA应当比较消息中的信任书和这个密钥组对应索引的信任书。
   1. 如果他们不匹配，那么UA必须通知用户信任书改变了











 

 





Could not transfer artifact com.ziyan.common:zte-mrf:pom:1.3.15 from/to bintray.kotlin.eap (https://dl.bintray.com/kotlin/kotlin-eap): Authorization failed for https://dl.bintray.com/kotlin/kotlin-eap/com/ziyan/common/zte-mrf/1.3.15/zte-mrf-1.3.15.pom 403 Forbidden



 
