# *Algorithm4*

# 第一章 基础


## 开始之前


用简单的语言讲清楚几个基本的概念


1. 算法
    1. 一种**有限**、**确定**、**有效**的并适用于计算机程序来实现的解决问题的方法
    2. 算法是计算机科学的基础，是领域研究的核心
    3. 算法适合与在任何计算机上用任何编程语言实现



2. 数据结构
    1. 数据结构是算法的副产品或结果


## 1.1 编程基础模型


1. 编写递归时最重要的三点
    1. 总有一个**最简单的情况**——递归头
    1. 递归调用总是尝试解决一个**规模更小**的子问题
    1. 递归调用的父问题和尝试解决的子问题之间**不应该有交集**


## 1.2 数据抽象(面向对象)


## 1.3 背包、队列和栈


1. 背包(Bag)
    1. 定义
        1. 是一种不支持从中删除元素的集合数据类型

    2. 目的 
         1. 收集元素与迭代遍历



2. 队列(Queue)
    1. 定义
        1. 基于先进先出策略的集合类型
    2. 特点/目的 
         1. 在用集合保存元素的同时**保存它们的相对顺序**，使它入列顺序和出列顺序相同



3. 栈
    1. 定义
4. 基于后进先出策略的集合类型
    1. 特点/目的
        1. 在用集合保存元素的同时**颠倒它们的相对顺序**



4. 自定义实现泛型栈



```java
public class MyStack<T>{
  //stack entries
  private T[] a;  
  private int N;
  //Java中不允许创建泛型数组,需要使用类型转换
  public MyStack(int cap){
    a = (T[]) new Object[cap];    
  }
  public boolean isEmpty(){
    return N == 0;
  }
  public int siza(){
    return N;
  }
  
  public void push(T t){
    if(N == a.length){
      resize(2*a.length);
    }
    a[N++] = t;
  }
  
  public T pop(){
    T t = a[--N];
    a[N] = null;
    if(N>0 && N == a.length/4){
      resize(a.length/2);
    }
    return t;
  }
  
  private void resize(int max){
    //将栈移到新的大小为max的数组
    T[] temp = (T[]) new Object[max];
    for(int i=0;i<N;i++){
      temp[i] = a[i];
    }
    a = temp;
  }
}
```


5. 任何集合类数据类型的实现的最佳性能
    1. 每项操作的用时都与集合大小无关
    1. 空间需求总是不超过集合大小乘以一个常数



6. 链表
    1. 定义
        1. 一种**递归**的数据结构，它或者为null，或者指向一个node的引用
        1. node含有一个泛型的元素和另一个指向另一条链表的引用
    2. 遍历


```java
for(Node x = first;x != null;x  = x.next){
  
}
```


## 1.4 算法分析

1. 将算法和某台计算机上的具体实现分离开是一个强大的概念；这使我们对算法的性能的知识可以应用于所有计算机
1. 增长数量级的分类

| 级别     | 增长数量级 | 代码示例  | 说明     | 举例           |
| -------- | ---------- | --------- | -------- | -------------- |
| 常数     | 1          | a = b + c | 普通语句 | 两数相加       |
| 对数     | logN       | 二分查找  | 二分飞掠 | 二分查找       |
| 线性     | N          | for循环   | 循环     | 找出最大元素   |
| 线性对数 | NlogN      |           | 分治     | 归并排序       |
| 平方     | N2         |           | 双层循环 | 检查所有元素对 |
| 立方     | N3         |           | 三层循环 | 检查所有三元组 |
| 指数     | 2N         |           | 穷举查找 | 检查所有子集   |

1. 一般内存的使用都会被填充为8字节
2. 清晰正确的代码始终是首要的任务
3. 要关注的是程序的运行成本

## 1.5 union-find算法

### 问题描述

1. 前提：假设有n个点，每个点分别记作0，1，2，3...n-1，他们按照某种顺序排列，
2. input：整数对：[1,2] -> 代表将点1和点2相连
3. output：最终有多少个连通分量(与其他的点无法接触/连通)







# 第二章 排序


# 第三章 查找


# 第四章 图


# 第五章 字符串


# 
